

<!DOCTYPE html>


<html lang="de" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

    <title>Datenanalyse &#8212; Yannick Frommherz</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "light";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../../_static/styles/theme.css?digest=e353d410970836974a52" rel="stylesheet" />
<link href="../../_static/styles/bootstrap.css?digest=e353d410970836974a52" rel="stylesheet" />
<link href="../../_static/styles/pydata-sphinx-theme.css?digest=e353d410970836974a52" rel="stylesheet" />

  
  <link href="../../_static/vendor/fontawesome/6.1.2/css/all.min.css?digest=e353d410970836974a52" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.1.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.1.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.1.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" href="../../_static/styles/sphinx-book-theme.css?digest=14f4ca6b54d191a8c7657f6c759bf11a5fb86285" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/design-style.4045f2051d55cab465a707391d5b2007.min.css" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../_static/scripts/bootstrap.js?digest=e353d410970836974a52" />
<link rel="preload" as="script" href="../../_static/scripts/pydata-sphinx-theme.js?digest=e353d410970836974a52" />

    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/clipboard.min.js"></script>
    <script src="../../_static/copybutton.js"></script>
    <script src="../../_static/scripts/sphinx-book-theme.js?digest=5a5c038af52cf7bc1a1ec88eea08e6366ee68824"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../../_static/togglebutton.js"></script>
    <script src="../../_static/translations.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="../../_static/design-tabs.js"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"
const thebe_selector = ".thebe,.cell"
const thebe_selector_input = "pre"
const thebe_selector_output = ".output, .cell_output"
</script>
    <script async="async" src="../../_static/sphinx-thebe.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'programming/1_Notebooks/7_Datenanalyse';</script>
    <link rel="canonical" href="https://github.com/yannickfrommherz/yfrommherz.ch/programming/1_Notebooks/7_Datenanalyse.html" />
    <link rel="index" title="Stichwortverzeichnis" href="../../genindex.html" />
    <link rel="search" title="Suche" href="../../search.html" />
    <link rel="next" title="L√∂sungen" href="../../solutions.html" />
    <link rel="prev" title="Regul√§re Ausdr√ºcke / RegEx" href="6_Regulaere_Ausdruecke.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="de"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <a class="skip-link" href="#main-content">Skip to main content</a>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__primary"
          id="__primary"/>
  <label class="overlay overlay-primary" for="__primary"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__secondary"
          id="__secondary"/>
  <label class="overlay overlay-secondary" for="__secondary"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search this book..."
         aria-label="Search this book..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>
  
    <nav class="bd-header navbar navbar-expand-lg bd-navbar">
    </nav>
  
  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">
  

<a class="navbar-brand logo" href="../../start.html">
  
  
  
  
    
    
      
    
    
    <img src="../../_static/logo.png" class="logo__image only-light" alt="Logo image"/>
    <script>document.write(`<img src="../../_static/logo.png" class="logo__image only-dark" alt="Logo image"/>`);</script>
  
  
</a></div>
        <div class="sidebar-primary-item"><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        <p aria-level="2" class="caption" role="heading"><span class="caption-text">About me</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../../resume.html">R√©sum√©</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../phd.html">PhD project</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../publications.html">Publications</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Hello Humanities!</span></p>
<ul class="current nav bd-sidenav">
<li class="toctree-l1 current active has-children"><a class="reference internal" href="../../notebooks.html">Notebooks</a><input checked="" class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-1"><i class="fa-solid fa-chevron-down"></i></label><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="1_Einfuehrung.html">1. Einf√ºhrung</a></li>
<li class="toctree-l2"><a class="reference internal" href="2_Datentypen.html">2. Datentypen</a></li>
<li class="toctree-l2"><a class="reference internal" href="3_Kontrollstrukturen.html">3. Kontrollstrukturen</a></li>
<li class="toctree-l2"><a class="reference internal" href="4_Funktionen_und_Methoden.html">4. Funktionen und Methoden</a></li>
<li class="toctree-l2"><a class="reference internal" href="5_Input_und_Output.html">5. Input und Output</a></li>
<li class="toctree-l2"><a class="reference internal" href="6_Regulaere_Ausdruecke.html">6. Regul√§re Ausdr√ºcke</a></li>
<li class="toctree-l2 current active"><a class="current reference internal" href="#">7. Datenanalyse</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../solutions.html">L√∂sungen zu den Notebooks</a><input class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-2"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="Loesungen/1_Einfuehrung_Loesungen.html">1. Einf√ºhrung</a></li>
<li class="toctree-l2"><a class="reference internal" href="Loesungen/2_Datentypen_Loesungen.html">2. Datentypen</a></li>
<li class="toctree-l2"><a class="reference internal" href="Loesungen/3_Kontrollstrukturen_Loesungen.html">3. Kontrollstrukturen</a></li>
<li class="toctree-l2"><a class="reference internal" href="Loesungen/4_Funktionen_und_Methoden_Loesungen.html">4. Funktionen und Methoden</a></li>
<li class="toctree-l2"><a class="reference internal" href="Loesungen/5_Input_und_Output_Loesungen.html">5. Input und Output</a></li>
<li class="toctree-l2"><a class="reference internal" href="Loesungen/6_Regulaere_Ausdruecke_Loesungen.html">6. Regul√§re Ausdr√ºcke</a></li>
<li class="toctree-l2"><a class="reference internal" href="Loesungen/7_Datenanalyse_Loesungen.html">7. Datenanalyse</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../extra_exercises.html">Zusatz√ºbungen</a><input class="toctree-checkbox" id="toctree-checkbox-3" name="toctree-checkbox-3" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-3"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../4_Zusatzuebungen/1_Einfuehrung_Uebungen.html">1. Einf√ºhrung</a></li>
<li class="toctree-l2"><a class="reference internal" href="../4_Zusatzuebungen/2_Datentypen_Uebungen.html">2. Datentypen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../4_Zusatzuebungen/3_Kontrollstrukturen_Uebungen.html">3. Kontrollstrukturen</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../extra_exercises_solutions.html">L√∂sungen zu den Zusatz√ºbungen</a><input class="toctree-checkbox" id="toctree-checkbox-4" name="toctree-checkbox-4" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-4"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../4_Zusatzuebungen/Loesungen/1_Einfuehrung_Uebungen_Loesungen.html">1. Einf√ºhrung</a></li>
<li class="toctree-l2"><a class="reference internal" href="../4_Zusatzuebungen/Loesungen/2_Datentypen_Uebungen_Loesungen.html">2. Datentypen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../4_Zusatzuebungen/Loesungen/3_Kontrollstrukturen_Uebungen_Loesungen.html">3. Kontrollstrukturen</a></li>
</ul>
</li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><label class="sidebar-toggle primary-toggle btn btn-sm" for="__primary" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</label></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">





<div class="dropdown dropdown-launch-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Launch interactive content">
    <i class="fas fa-rocket"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="https://mybinder.org/v2/gh/yannickfrommherz/yfrommherz.ch/main?urlpath=lab/tree/website/programming/1_Notebooks/7_Datenanalyse.ipynb" target="_blank"
   class="btn btn-sm dropdown-item"
   title="Launch onBinder"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  
    <img src="../../_static/images/logo_binder.svg">
  </span>
<span class="btn__text-container">Binder</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="initThebeSBT()"
  class="btn btn-sm btn-launch-thebe dropdown-item"
  title="Launch Thebe"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-play"></i>
  </span>
<span class="btn__text-container">Live Code</span>
</button>
</li>
      
  </ul>
</div>






<div class="dropdown dropdown-source-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Source repositories">
    <i class="fab fa-github"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="https://github.com/yannickfrommherz/yfrommherz.ch" target="_blank"
   class="btn btn-sm btn-source-repository-button dropdown-item"
   title="Quell-Repository"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fab fa-github"></i>
  </span>
<span class="btn__text-container">Repository</span>
</a>
</li>
      
      
      
      
      <li><a href="https://github.com/yannickfrommherz/yfrommherz.ch/issues/new?title=Issue%20on%20page%20%2Fprogramming/1_Notebooks/7_Datenanalyse.html&body=Your%20issue%20content%20here." target="_blank"
   class="btn btn-sm btn-source-issues-button dropdown-item"
   title="√ñffnen Sie ein Problem"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-lightbulb"></i>
  </span>
<span class="btn__text-container">Open issue</span>
</a>
</li>
      
  </ul>
</div>






<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Laden Sie diese Seite herunter">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="../../_sources/programming/1_Notebooks/7_Datenanalyse.ipynb" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="Quelldatei herunterladen"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.ipynb</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="In PDF drucken"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Vollbildmodus"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>


<script>
document.write(`
  <button class="theme-switch-button btn btn-sm btn-outline-primary navbar-btn rounded-circle" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="theme-switch" data-mode="light"><i class="fa-solid fa-sun"></i></span>
    <span class="theme-switch" data-mode="dark"><i class="fa-solid fa-moon"></i></span>
    <span class="theme-switch" data-mode="auto"><i class="fa-solid fa-circle-half-stroke"></i></span>
  </button>
`);
</script>

<script>
document.write(`
  <button class="btn btn-sm navbar-btn search-button search-button__button" title="Suche" aria-label="Suche" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
  </button>
`);
</script>
<label class="sidebar-toggle secondary-toggle btn btn-sm" for="__secondary"title="Toggle secondary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-list"></span>
</label>
</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>Datenanalyse</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> Inhalt </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#input">Input</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#uberblick-bekommen">√úberblick bekommen</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#anwendungsfall-wortverlaufskurven-visualisieren">üîß Anwendungsfall: Wortverlaufskurven visualisieren üìà</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#auf-spalten-zugreifen">Auf Spalten zugreifen</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#auf-zeilen-zugreifen">Auf Zeilen zugreifen</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#auf-spalten-und-zeilen-zugreifen">Auf Spalten <em>und</em> Zeilen zugreifen</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#spalten-hinzufugen">Spalten hinzuf√ºgen</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#zeilen-hinzufugen">Zeilen hinzuf√ºgen</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#spalten-und-zeilen-entfernen">Spalten und Zeilen entfernen</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#deskriptive-statistiken">Deskriptive Statistiken</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#werte-sortieren">Werte sortieren</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#einzigartige-werte">Einzigartige Werte</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#dataframe-filtern">DataFrame filtern</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#werte-zahlen">Werte z√§hlen</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#werte-bearbeiten">Werte bearbeiten</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#strings">Strings</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#numerische-werte">Numerische Werte</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#datentyp-andern">Datentyp √§ndern</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#bedingte-bearbeitung">Bedingte Bearbeitung</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#apply-und-applymap"><code class="docutils literal notranslate"><span class="pre">apply</span></code> und <code class="docutils literal notranslate"><span class="pre">applymap</span></code></a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id1">üîß Anwendungsfall: Wortverlaufskurven visualisieren üìà</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#output">Output</a></li>
</ul>
            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article" role="main">
                  
  <section id="datenanalyse">
<h1>Datenanalyse<a class="headerlink" href="#datenanalyse" title="Permalink to this heading">#</a></h1>
<p>In diesem Notebook lernen wir, wie wir in Python gro√üe Mengen an strukturierten Daten, allen voran Daten in Form von Tabellen, verarbeiten und analysieren k√∂nnen.</p>
<p>Im f√ºnften Notebook haben wir mit folgender Tabelle gearbeitet:</p>
<img src="../3_Dateien/Grafiken_und_Videos/Fl√§chengr√∂sste_Gemeinden_Tabelle.png"><p>Wir haben unter Zuhilfenahme des <code class="docutils literal notranslate"><span class="pre">csv</span></code>-Moduls unseren eigenen Code geschrieben, um auszurechnen, wieviele der 100 fl√§chengr√∂√üten Gemeinden sich in jedem der sechzehn Bundesl√§nder befinden. In diesem Notebook lernen wir die sehr viel leistungsst√§rkere Bibliothek <em>pandas</em> kennen, die uns diese Rechnung im Handumdrehen liefern kann. Pandas kann aber viel mehr, wie wir gleich sehen werden.</p>
<p>Zu Beginn m√ºssen wir pandas nat√ºrlich importieren. Folgendes Statement importiert die Bibliothek und verleiht ihr den Namen <code class="docutils literal notranslate"><span class="pre">pd</span></code>. Diese Abk√ºrzung ist eine Konvention.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
</pre></div>
</div>
</div>
</div>
<p>Solltest Du einen <code class="docutils literal notranslate"><span class="pre">ModuleNotFoundError</span></code> erhalten, musst Du <code class="docutils literal notranslate"><span class="pre">pandas</span></code> erst √ºber die Command Line installieren. √ñffne dazu das Terminal (macOS) bzw. die Eingabeaufforderung (Windows) in einem neuen Fenster, gib <code class="docutils literal notranslate"><span class="pre">pip3</span> <span class="pre">install</span> <span class="pre">pandas</span></code> (macOS) bzw. <code class="docutils literal notranslate"><span class="pre">pip</span> <span class="pre">install</span> <span class="pre">pandas</span></code> (Windows) ein und dr√ºcke auf Enter. Sobald der Prozess abgeschlossen ist, sollte der Import oben klappen.</p>
<p>Um pandas kennenzulernen, wollen wir mit einem gro√üen Datensatz arbeiten, n√§mlich dem <a class="reference external" href="https://songkorpus.de/index.html">Songkorpus</a>. Das Songkorpus beinh√§lt Lieder von bekannten deutschen K√ºnstler:innen, u.a. von Udo Lindenberg und Fettes Brot und umspannt die Jahre 1969-2022. √ñffentlich herunterladbar sind unter anderem Worth√§ufigkeiten pro Jahr und zwar als Tabelle (auf der Webseite selbst finden sich weitere spannende Daten und Analysen). Jedes Wort, das in einem oder mehreren Songs in einem bestimmten Jahr vorkommt, steht in einer eigenen Zeile, zusammen mit dem entsprechenden Jahr und der H√§ufigkeit, mit der es in diesem Jahr bei allen K√ºnstler:innen auftritt (s.u.). Insgesamt handelt es sich um √ºber 380.000 W√∂rter. Solch eine tabellarische Datei, zumal derart gro√ü, ist pr√§destiniert dazu, mit pandas verarbeitet zu werden.</p>
<section id="input">
<h2>Input<a class="headerlink" href="#input" title="Permalink to this heading">#</a></h2>
<p>In der folgenden Zelle √∂ffnen wir die Datei, die sich bereits in ‚Äû3_Dateien/Songkorpus‚Äú befindet, und lesen sie mit der pandas-Funktion <code class="docutils literal notranslate"><span class="pre">read_csv</span></code> ein, die neben dem Dateipfad u.a. auch das Trennzeichen (<code class="docutils literal notranslate"><span class="pre">sep</span></code>, in diesem Fall der Tabulator ‚Äû\t‚Äú) als Argument nimmt:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1">#vor read_csv steht wie gewohnt der Modulname, damit Python wei√ü, wo sich die Funktion befindet</span>
<span class="n">songkorpus</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s2">&quot;../3_Dateien/Songkorpus/songkorpus_token.tsv&quot;</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span><span class="p">)</span> 
</pre></div>
</div>
</div>
</div>
<p>Neben <code class="docutils literal notranslate"><span class="pre">read_csv</span></code> f√ºr Dateien mit Trennzeichen, bietet pandas u.a. auch Funktionen f√ºr XML (<code class="docutils literal notranslate"><span class="pre">read_xml</span></code>), JSON (<code class="docutils literal notranslate"><span class="pre">read_json</span></code>)  und Excel-Dateien (<code class="docutils literal notranslate"><span class="pre">read_excel</span></code>) an. Ebenfalls kann man je nach Daten weitere Parameter spezifizieren, u.a. <code class="docutils literal notranslate"><span class="pre">na_filter</span></code>, um zu definieren, wie mit fehlenden Werten (sog. <em>NaN-Werten</em>) umgegangen werden soll.</p>
<p><em>Bemerkung am Rande: Fehlende Werte f√ºhren immer wieder zu Problemen bei der Arbeit mit pandas. Deswegen solltest Du Dich beim Einlesen Deiner eigenen Daten stets fragen, ob bestimmte Werte darin fehlen k√∂nnten und wenn ja, wie Du damit umgehen m√∂chtest. Pandas bietet neben <code class="docutils literal notranslate"><span class="pre">na_filter</span></code> n√ºtzliche Methoden wie <code class="docutils literal notranslate"><span class="pre">isna</span></code>, <code class="docutils literal notranslate"><span class="pre">dropna</span></code> und <code class="docutils literal notranslate"><span class="pre">fillna</span></code> f√ºr den Umgang mit fehlenden Werten (mehr Infos <a class="reference external" href="https://pandas.pydata.org/docs/user_guide/missing_data.html">hier</a>). Im Folgenden gehen wir aber nicht darauf ein, im Songkorpus fehlen schlicht keine Werte.</em></p>
<p>Die Lesemethode √ºberf√ºhrt unsere Daten in jedem Fall in ein sog. <em>DataFrame</em>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">songkorpus</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>&lt;class &#39;pandas.core.frame.DataFrame&#39;&gt;
</pre></div>
</div>
</div>
</div>
<p>DataFrames sind ein eigener Datentyp von pandas, auf dem wir eine Vielzahl n√ºtzlicher Operationen ausf√ºhren k√∂nnen, etwa um einen √úberblick √ºber die Daten zu bekommen.</p>
</section>
<section id="uberblick-bekommen">
<h2>√úberblick bekommen<a class="headerlink" href="#uberblick-bekommen" title="Permalink to this heading">#</a></h2>
<p>Hier bietet sich insbesondere die Methode <code class="docutils literal notranslate"><span class="pre">head</span></code> an, die standardm√§√üig die ersten f√ºnf Zeilen (also den ‚ÄûKopf‚Äú) des DataFrames ausgibt:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">songkorpus</span><span class="o">.</span><span class="n">head</span><span class="p">()</span> <span class="c1">#head nimmt optional eine Ganzzahl als Argument, die definiert, wieviele der ersten Zeilen ausgegeben werden sollen</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html"><div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>CO_TOKEN</th>
      <th>CO_YEAR</th>
      <th>CO_COUNT</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>Klaround</td>
      <td>2007</td>
      <td>1</td>
    </tr>
    <tr>
      <th>1</th>
      <td>#3</td>
      <td>2009</td>
      <td>1</td>
    </tr>
    <tr>
      <th>2</th>
      <td>#Babo</td>
      <td>2015</td>
      <td>1</td>
    </tr>
    <tr>
      <th>3</th>
      <td>#JeSuisPass√©ChezSo</td>
      <td>2018</td>
      <td>1</td>
    </tr>
    <tr>
      <th>4</th>
      <td>#Nachbar</td>
      <td>2016</td>
      <td>1</td>
    </tr>
  </tbody>
</table>
</div></div></div>
</div>
<p>Eher komische W√∂rter in der Spalte ‚ÄûCO_TOKEN‚Äú. Wie wir an Spalte ‚ÄûCO_COUNT‚Äú erkennen k√∂nnen, kamen sie aber auch nur jeweils einmal (im angegeben Jahr in ‚ÄûCO_YEAR‚Äú) vor.</p>
<p>Das Gegenst√ºck zu <code class="docutils literal notranslate"><span class="pre">head</span></code> ist <code class="docutils literal notranslate"><span class="pre">tail</span></code> (also der ‚ÄûSchwanz‚Äú), wodurch wir die letzten f√ºnf Zeilen des DataFrames erhalten:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">songkorpus</span><span class="o">.</span><span class="n">tail</span><span class="p">()</span> <span class="c1">#auch tail nimmt optional eine Ganzzahl als Argument, die definiert, wieviele der letzten Zeilen ausgegeben werden sollen</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html"><div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>CO_TOKEN</th>
      <th>CO_YEAR</th>
      <th>CO_COUNT</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>386505</th>
      <td>ÔªøVierzehn</td>
      <td>2020</td>
      <td>1</td>
    </tr>
    <tr>
      <th>386506</th>
      <td>ÔªøWas</td>
      <td>2020</td>
      <td>1</td>
    </tr>
    <tr>
      <th>386507</th>
      <td>ÔªøWei√üer</td>
      <td>2020</td>
      <td>1</td>
    </tr>
    <tr>
      <th>386508</th>
      <td>ÔªøWie</td>
      <td>2020</td>
      <td>1</td>
    </tr>
    <tr>
      <th>386509</th>
      <td>ÔªøWozu</td>
      <td>2020</td>
      <td>1</td>
    </tr>
  </tbody>
</table>
</div></div></div>
</div>
<p>Die Ausgabe sieht √ºbrigens anders aus, wenn wir einen <code class="docutils literal notranslate"><span class="pre">print</span></code>-Befehl verwenden, anstatt dass JupyterLab schlicht die letzte Zeile ausgibt (probier‚Äôs aus!). Mit <code class="docutils literal notranslate"><span class="pre">print</span></code>-Befehl verschwindet die angenehme Formatierung.</p>
<p>Mithilfe von <code class="docutils literal notranslate"><span class="pre">shape</span></code>, <code class="docutils literal notranslate"><span class="pre">columns</span></code> und <code class="docutils literal notranslate"><span class="pre">index</span></code> k√∂nnen wir au√üerdem in Erfahrung bringen, welches Format (<code class="docutils literal notranslate"><span class="pre">shape</span></code>), d.h. wieviele Spalten und Zeilen, das DataFrame hat, sowie, wie Spalten (<code class="docutils literal notranslate"><span class="pre">columns</span></code>) und Zeilen (<code class="docutils literal notranslate"><span class="pre">index</span></code>) benannt sind.</p>
<p>‚ö†Ô∏è Achtung: Es handelt sich dabei um sog. Attribute des DataFrames, die wir uns vereinfacht gesagt als Eigenschaften des DataFrames vorstellen k√∂nnen. Um auf ein Attribut eines Objekts zuzugreifen, h√§ngt man den Namen des Attributs wie bei Methoden nach einem Punkt an das betreffende Objekt, schlie√üt aber nicht mit Klammern ab:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">songkorpus</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">songkorpus</span><span class="o">.</span><span class="n">columns</span><span class="p">,</span> <span class="n">songkorpus</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="n">original_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">songkorpus</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>(386510, 3)
Index([&#39;CO_TOKEN&#39;, &#39;CO_YEAR&#39;, &#39;CO_COUNT&#39;], dtype=&#39;object&#39;)
RangeIndex(start=0, stop=386510, step=1)
</pre></div>
</div>
</div>
</div>
<p>Unser DataFrame besteht also aus 386.510 Zeilen und drei Spalten. Die Anzahl an Zeilen, also die L√§nge des DataFrames, speichern wir in einer separaten Variablen ab, wir werden sie sp√§ter noch brauchen.</p>
<p>Die Spaltennamen sind ‚ÄûCO_TOKEN‚Äú, ‚ÄûCO_YEAR‚Äú und ‚ÄûCO_COUNT‚Äú und die Zeilen sind mit Indizes von 0 (inklusive) bis 386510 (exklusive) durchnummeriert.</p>
<p>Die etwas kryptischen Spaltennamen k√∂nnen wir √§ndern, indem wir das Attribut <code class="docutils literal notranslate"><span class="pre">columns</span></code> unseres DataFrames ganz einfach mit einer Liste an neuen Spaltennamen √ºberschreiben:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">songkorpus</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;Wort&quot;</span><span class="p">,</span> <span class="s2">&quot;Jahr&quot;</span><span class="p">,</span> <span class="s2">&quot;H√§ufigkeit&quot;</span><span class="p">]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">songkorpus</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Index([&#39;Wort&#39;, &#39;Jahr&#39;, &#39;H√§ufigkeit&#39;], dtype=&#39;object&#39;)
</pre></div>
</div>
</div>
</div>
<p>Die L√§nge der Liste muss nat√ºrlich der Anzahl an Spalten entsprechen.</p>
<p>Um eine spezifische Spalte zu √ºberschreiben, k√∂nnen wir die <code class="docutils literal notranslate"><span class="pre">rename</span></code>-Methode verwenden, derer wir ein dictionary mit Schl√ºssel-Werte-Paaren ({‚Äûjetziger Name‚Äú: ‚Äûneuer Name‚Äú}) √ºbergeben. Im Allgemeinen haben wir beim Bearbeiten eines DataFrames zwei M√∂glichkeiten, um die Bearbeitung wirksam zu machen:</p>
<ol class="arabic simple">
<li><p>Wir k√∂nnen immer das alte DataFrame mit der bearbeiteten Version √ºberschreiben. So haben wir das auch in der Zelle obendran gehandhabt.</p></li>
<li><p>Bei der Bearbeitung mithilfe einer Methode, hier <code class="docutils literal notranslate"><span class="pre">rename</span></code>, k√∂nnen wir auch den Parameter <code class="docutils literal notranslate"><span class="pre">inplace=True</span></code> spezifizieren, um die Bearbeitung ‚Äûan Ort und Stelle‚Äú vorzunehmen.</p></li>
</ol>
<p>In der n√§chsten Zelle sehen wir beide Alternativen. Im Folgenden beschr√§nken wir uns aber auf die erste M√∂glichkeit, da diese auch abseits von Methoden funktioniert.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">songkorpus</span> <span class="o">=</span> <span class="n">songkorpus</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;Wort&quot;</span><span class="p">:</span> <span class="s2">&quot;Token&quot;</span><span class="p">})</span> <span class="c1">#1. M√∂glichkeit: √úberschreiben</span>
<span class="n">songkorpus</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;Wort&quot;</span><span class="p">:</span> <span class="s2">&quot;Token&quot;</span><span class="p">},</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="c1">#2. M√∂glichkeit: Bearbeiten &quot;inplace&quot;/&quot;an Ort und Stelle&quot;</span>
<span class="n">songkorpus</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html"><div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Token</th>
      <th>Jahr</th>
      <th>H√§ufigkeit</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>Klaround</td>
      <td>2007</td>
      <td>1</td>
    </tr>
    <tr>
      <th>1</th>
      <td>#3</td>
      <td>2009</td>
      <td>1</td>
    </tr>
    <tr>
      <th>2</th>
      <td>#Babo</td>
      <td>2015</td>
      <td>1</td>
    </tr>
    <tr>
      <th>3</th>
      <td>#JeSuisPass√©ChezSo</td>
      <td>2018</td>
      <td>1</td>
    </tr>
    <tr>
      <th>4</th>
      <td>#Nachbar</td>
      <td>2016</td>
      <td>1</td>
    </tr>
  </tbody>
</table>
</div></div></div>
</div>
<p>Schon kennen wir erste n√ºtzliche Operationen f√ºr einen ersten Eindruck unserer Daten.</p>
</section>
<hr class="docutils" />
<section id="anwendungsfall-wortverlaufskurven-visualisieren">
<h2>üîß Anwendungsfall: Wortverlaufskurven visualisieren üìà<a class="headerlink" href="#anwendungsfall-wortverlaufskurven-visualisieren" title="Permalink to this heading">#</a></h2>
<p>Auch in diesem Notebook gibt es einen Anwendungsfall: Wir wollen visualisieren, wie h√§ufig beliebige W√∂rter in jedem Jahr im vom Songkorpus abgedeckten Zeitraum 1969-2022 vorkommen. F√ºr die Begriffe ‚Äûich‚Äú, ‚Äûdu‚Äú, ‚Äûer‚Äú und ‚Äûsie‚Äú s√§he das z.B. so aus:</p>
<img src="../3_Dateien/Grafiken_und_Videos/Wortverlaufskurve_Jahr.png" width="700">
<p>Es scheint, als s√§ngen die K√ºnstler:innen im Songkorpus bevorzugt √ºber sich selbst. üòÖ</p>
<hr class="docutils" />
<p>Zuallererst wollen wir einen detailierten Blick auf Spalten und Zeilen werfen, aus denen ein DataFrame ja besteht.</p>
</section>
<section id="auf-spalten-zugreifen">
<h2>Auf Spalten zugreifen<a class="headerlink" href="#auf-spalten-zugreifen" title="Permalink to this heading">#</a></h2>
<p>Wenn wir an einer bestimmten Spalte eines DataFrames interessiert sind, k√∂nnen wir auf diese mit der gleichen Syntax wie bei dictionaries zugreifen:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">songkorpus</span><span class="p">[</span><span class="s2">&quot;Token&quot;</span><span class="p">]</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>0                   Klaround
1                         #3
2                      #Babo
3         #JeSuisPass√©ChezSo
4                   #Nachbar
                 ...        
386505             ÔªøVierzehn
386506                  ÔªøWas
386507               ÔªøWei√üer
386508                  ÔªøWie
386509                 ÔªøWozu
Name: Token, Length: 386510, dtype: object
</pre></div>
</div>
</div>
</div>
<p>An dieser Stelle ist es nat√ºrlich wichtig, dass die Spalte aktuell wirklich ‚ÄûToken‚Äú und nicht mehr ‚ÄûCO_TOKEN‚Äú oder ‚ÄûWort‚Äú hei√üt. Dies w√ºrde, wie bei inexistenten Schl√ºsseln in einem dictionary auch, zu einem <code class="docutils literal notranslate"><span class="pre">KeyError</span></code> f√ºhren.</p>
<p>Weiter funktioniert f√ºr den Spaltenzugriff auch die sog. dot-Notation nach dem Schema <code class="docutils literal notranslate"><span class="pre">DataFrame.column</span></code>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">songkorpus</span><span class="o">.</span><span class="n">Token</span> <span class="c1">#beachte, dass hierf√ºr der Spaltenname nicht als string, also ohne Anf√ºhrungszeichen angeh√§ngt wird!</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>0                   Klaround
1                         #3
2                      #Babo
3         #JeSuisPass√©ChezSo
4                   #Nachbar
                 ...        
386505             ÔªøVierzehn
386506                  ÔªøWas
386507               ÔªøWei√üer
386508                  ÔªøWie
386509                 ÔªøWozu
Name: Token, Length: 386510, dtype: object
</pre></div>
</div>
</div>
</div>
<p>Die dot-Notation erf√ºllt (fast immer) die gleiche Funktion wie die Zugriffsweise √ºber eckige Klammern, auf die wir uns fortan beschr√§nken.</p>
<p>In jedem Fall entspricht das, was wir dabei zur√ºckerhalten, dem zweiten wichtigen Datentyp von pandas neben <em>DataFrame</em>, n√§mlich einer sog. <em>Series</em>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">tokens</span> <span class="o">=</span> <span class="n">songkorpus</span><span class="p">[</span><span class="s2">&quot;Token&quot;</span><span class="p">]</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">tokens</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>&lt;class &#39;pandas.core.series.Series&#39;&gt;
</pre></div>
</div>
</div>
</div>
<p>Series kann man mit Listen vergleichen. Sie sind im Gegensatz zu Dataframes nicht zweidimensional (Spalten und Zeilen), sondern eindimensional. Viele Listen-Operationen wie z.B. Indexing und Slicing funktionieren bei Series gleicherma√üen:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">tokens</span><span class="p">[</span><span class="mi">10000</span><span class="p">],</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span> <span class="c1">#Indexing</span>
<span class="nb">print</span><span class="p">(</span><span class="n">tokens</span><span class="p">[</span><span class="mi">9999</span><span class="p">:</span><span class="mi">10002</span><span class="p">])</span> <span class="c1">#Slicing</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Atzenmusik 

9999      Atzenlogo
10000    Atzenmusik
10001    Atzenparty
Name: Token, dtype: object
</pre></div>
</div>
</div>
</div>
<hr class="docutils" />
<p>‚úèÔ∏è <strong>√úbung 1:</strong> Erstelle eine weitere Series, die nur das 100.000te, 200.000te und 300.000te Token der Series <code class="docutils literal notranslate"><span class="pre">tokens</span></code> beinh√§lt.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1">#In diese Zelle kannst Du den Code zur √úbung schreiben</span>
</pre></div>
</div>
</div>
</div>
<hr class="docutils" />
<p>Anstatt <em>eines</em> Spaltennamens k√∂nnen wir auch eine Liste an Spaltennamen √ºbergeben, um auf mehrere Spalten gleichzeitig zuzugreifen:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">two_columns</span> <span class="o">=</span> <span class="n">songkorpus</span><span class="p">[[</span><span class="s2">&quot;Token&quot;</span><span class="p">,</span> <span class="s2">&quot;Jahr&quot;</span><span class="p">]]</span><span class="o">.</span><span class="n">head</span><span class="p">()</span> <span class="c1">#beachte die inneren eckigen Klammern f√ºr die Liste!</span>
<span class="n">two_columns</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html"><div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Token</th>
      <th>Jahr</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>Klaround</td>
      <td>2007</td>
    </tr>
    <tr>
      <th>1</th>
      <td>#3</td>
      <td>2009</td>
    </tr>
    <tr>
      <th>2</th>
      <td>#Babo</td>
      <td>2015</td>
    </tr>
    <tr>
      <th>3</th>
      <td>#JeSuisPass√©ChezSo</td>
      <td>2018</td>
    </tr>
    <tr>
      <th>4</th>
      <td>#Nachbar</td>
      <td>2016</td>
    </tr>
  </tbody>
</table>
</div></div></div>
</div>
<p>√úberlege Dir kurz, was f√ºr ein Datentyp <code class="docutils literal notranslate"><span class="pre">two_columns</span></code> hat.</p>
<p>Genau: Nun haben wir nicht mehr nur eine Spalte, in der Zeilenwert um Zeilenwert in einer Dimension gespeichert ist, sondern zwei Spalten. <code class="docutils literal notranslate"><span class="pre">two_columns</span></code> ist also immer noch ein zweidimensionales Objekt, sprich ein DataFrame:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">two_columns</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>&lt;class &#39;pandas.core.frame.DataFrame&#39;&gt;
</pre></div>
</div>
</div>
</div>
<p>Nun wissen wir, wie wir auf Spalten zugreifen k√∂nnen.</p>
</section>
<section id="auf-zeilen-zugreifen">
<h2>Auf Zeilen zugreifen<a class="headerlink" href="#auf-zeilen-zugreifen" title="Permalink to this heading">#</a></h2>
<p>Um auf Zeilen zuzugreifen, h√§ngen wir <code class="docutils literal notranslate"><span class="pre">.loc[index]</span></code> an das DataFrame an und √ºbergeben den Index der gew√ºnschten Zeile anstelle von <code class="docutils literal notranslate"><span class="pre">index</span></code>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">songkorpus</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="mi">777</span><span class="p">]</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Token         16-J√§hrige
Jahr                2008
H√§ufigkeit             1
Name: 777, dtype: object
</pre></div>
</div>
</div>
</div>
<p>Verwende stets diese Syntax, um auf Zeilen zuzugreifen.</p>
<p>Anf√§nger:innen versuchen oft, die Syntax <code class="docutils literal notranslate"><span class="pre">DataFrame[index]</span></code> zu verwenden. Das f√ºhrt aber zu einem <code class="docutils literal notranslate"><span class="pre">KeyError</span></code>, denn diese Syntax ist dem Spaltenzugriff vorbehalten (sollte der √ºbergebene <code class="docutils literal notranslate"><span class="pre">index</span></code> zuf√§lligerweise auch ein Spaltenname sein, erhalten wir keinen <code class="docutils literal notranslate"><span class="pre">KeyError</span></code>, aber die Ausgabe entspricht dann auch der jeweiligen Spalte, und nicht der gew√ºnschten Zeile).</p>
<p>Da wir blo√ü auf eine einzige Zeile zugreifen, in der Spaltenwert um Spaltenwert in einer Dimension gespeichert ist, liegt wieder der Datentyp Series vor:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">songkorpus</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="mi">777</span><span class="p">]))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>&lt;class &#39;pandas.core.series.Series&#39;&gt;
</pre></div>
</div>
</div>
</div>
<p>Zur Verdeutlichung: Sowohl eine Sequenz von Werten einer Spalte als auch eine Sequenz von Werten einer Zeile entsprechen bei pandas einer Series. Entscheidend ist blo√ü, dass nur eine einzige Dimension vorliegt. Sobald ein Objekt sowohl mehrere Spalten als auch mehrere Zeilen umfasst, handelt es sich um ein DataFrame.</p>
<p>Ein solches Objekt k√∂nnen wir auch √ºber <code class="docutils literal notranslate"><span class="pre">loc</span></code> erhalten, indem wir auf mehrere Zeilen gleichzeitig zugreifen. Dies funktioniert wie bei dem Zugriff auf mehrere Spalten (s.o), indem wir mehrere Indizes als Liste √ºbergeben.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">songkorpus</span><span class="o">.</span><span class="n">loc</span><span class="p">[[</span><span class="mi">777</span><span class="p">,</span><span class="mi">888</span><span class="p">]]))</span> <span class="c1">#beachte die inneren eckigen Klammern f√ºr die Liste!</span>
<span class="n">songkorpus</span><span class="o">.</span><span class="n">loc</span><span class="p">[[</span><span class="mi">777</span><span class="p">,</span><span class="mi">888</span><span class="p">]]</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>&lt;class &#39;pandas.core.frame.DataFrame&#39;&gt;
</pre></div>
</div>
<div class="output text_html"><div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Token</th>
      <th>Jahr</th>
      <th>H√§ufigkeit</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>777</th>
      <td>16-J√§hrige</td>
      <td>2008</td>
      <td>1</td>
    </tr>
    <tr>
      <th>888</th>
      <td>1980</td>
      <td>1980</td>
      <td>3</td>
    </tr>
  </tbody>
</table>
</div></div></div>
</div>
<p>Zudem k√∂nnen wir auf mehrere aufeinanderfolgende Zeilen zugreifen, indem wir dieselbe Syntax wie bei Slicing verwenden:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">songkorpus</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="mi">777</span><span class="p">:</span><span class="mi">780</span><span class="p">]</span> <span class="c1">#keine inneren eckigen Klammern!</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html"><div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Token</th>
      <th>Jahr</th>
      <th>H√§ufigkeit</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>777</th>
      <td>16-J√§hrige</td>
      <td>2008</td>
      <td>1</td>
    </tr>
    <tr>
      <th>778</th>
      <td>16-Zoll</td>
      <td>2017</td>
      <td>1</td>
    </tr>
    <tr>
      <th>779</th>
      <td>16.</td>
      <td>2004</td>
      <td>11</td>
    </tr>
    <tr>
      <th>780</th>
      <td>16/1</td>
      <td>2000</td>
      <td>1</td>
    </tr>
  </tbody>
</table>
</div></div></div>
</div>
<p>Im Gegensatz zu gew√∂hnlichem Slicing bei Listen wird der letzte Index bei Pandas miteingerechnet (‚Äûinklusiv‚Äú, vgl. zweites Notebook).</p>
<p>Abschlie√üend sei erw√§hnt, dass Zeilen nicht zwingend mit <em>numerischen</em> Indizes durchnummeriert sein m√ºssen. Zeilen k√∂nnen wie Spalten ebenfalls Namen haben. Dieses Szenario wollen wir in der n√§chsten √úbung mit denselben Daten durchspielen.</p>
<hr class="docutils" />
<p>‚úèÔ∏è <strong>√úbung 2:</strong></p>
<ol class="arabic simple">
<li><p>Lies die Datei <code class="docutils literal notranslate"><span class="pre">songkorpus_tokens.tsv</span></code> abermals ein und √ºbergib beim Erstellen des DataFrames zus√§tzlich den Parameter <code class="docutils literal notranslate"><span class="pre">index_col=0</span></code>. Dadurch wird die erste Spalte (mit dem Index 0), also diejenige mit den Tokens, zur sog. <em>Index-Spalte</em>. Jede Zeile hat nun statt eines numerischen Index einen Namen, n√§mlich das jeweilige Token. Weise das DataFrame der Variablen <code class="docutils literal notranslate"><span class="pre">songkorpus_labelled_rows</span></code> zu.</p></li>
<li><p>Benenne die Spalten wie bei <code class="docutils literal notranslate"><span class="pre">songkorpus</span></code> um. Falls Du hier eine Fehlermeldung kriegst, lies sie aufmerksam und passe Deinen Code entsprechend an.</p></li>
<li><p>√úberlege Dir, was die Tatsache, dass wir nun Tokens als Zeilennamen verwenden, zur Konsequenz hat. Experimentiere dazu gerne mit dem DataFrame herum und greife auf verschiedene Zeilen √ºber Namen zu.</p></li>
</ol>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1">#In diese Zelle kannst Du den Code zur √úbung schreiben</span>
</pre></div>
</div>
</div>
</div>
<hr class="docutils" />
<p>Im Gegensatz zu Spaltennamen (und Schl√ºsseln bei dictionaries) d√ºrfen Zeilennamen mehrfach vorkommen. Der Zugriff auf eine oder mehrere Zeilen funktioniert ungeachtet dessen gleich wie bei DataFrames, die mit numerischen Indizes durchnummeriert sind, also mittels <code class="docutils literal notranslate"><span class="pre">.loc[index]</span></code>.</p>
<hr class="docutils" />
<p>‚úèÔ∏è <strong>√úbung 3:</strong> Setze die Tatsache, dass Zeilennamen mehrfach vorkommen d√ºrfen, produktiv ein und finde heraus, wie oft ‚ÄûDresden‚Äú in <code class="docutils literal notranslate"><span class="pre">songkorpus_labelled_rows</span></code> vorkommt, indem Du die H√§ufigkeiten in allen Jahren, in denen das Wort gesungen wird, zusammenz√§hlst.</p>
<p>üí° Tipp: Der erste Schritt besteht darin, aus dem gesamten DataFrame <code class="docutils literal notranslate"><span class="pre">songkorpus_labelled_rows</span></code> ein kleineres, sog. <em>Sub-DataFrame</em> zu erstellen, das mit einer neuen Variablen referenziert wird. Der zweite Schritt besteht darin, eine Series aus diesem Sub-DataFrame ‚Äûherauszuschneiden‚Äú, die Du anschlie√üend wie eine Liste behandeln kannst, um schlie√ülich zur Anzahl der Nennungen von ‚ÄûDresden‚Äú zu gelangen.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1">#In diese Zelle kannst Du den Code zur √úbung schreiben</span>
</pre></div>
</div>
</div>
</div>
</section>
<hr class="docutils" />
<section id="auf-spalten-und-zeilen-zugreifen">
<h2>Auf Spalten <em>und</em> Zeilen zugreifen<a class="headerlink" href="#auf-spalten-und-zeilen-zugreifen" title="Permalink to this heading">#</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">loc</span></code> k√∂nnen wir ebenfalls verwenden, um gleichzeitig anzugeben, auf welche Spalte(n) und Zeile(n) wir bei einem DataFrame zugreifen m√∂chten. Auf den Zeilenindex folgt nach einem Komma der gew√ºnschte Spaltenname:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">songkorpus</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="s2">&quot;Jahr&quot;</span><span class="p">])</span>

<span class="c1">#Randbemerkung: Auf die Spitze getrieben, k√∂nnen wir mit .loc auch nur auf Spalten zugreifen, n√§mlich, indem wir </span>
<span class="c1">#wie bei Listen-Slicing auch m√∂glich, durch Weglassen eines Start- und Endindex s√§mtliche Zeilen ansprechen, sprich so: </span>
<span class="c1">#songkorpus.loc[:, &quot;Jahr&quot;]</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>1995
</pre></div>
</div>
</div>
</div>
<p>Neben der Herangehensweise √ºber <code class="docutils literal notranslate"><span class="pre">loc</span></code> besteht auch die M√∂glichkeit erst wie oben gelernt auf eine spezifische Spalte bzw. eine spezifische Zeile zuzugreifen, was in einer Series resultiert, und in dieser Series anschlie√üend auf eine bestimmte Zeile bzw. eine bestimmte Spalte zuzugreifen (z.B. <code class="docutils literal notranslate"><span class="pre">songkorpus[&quot;Token&quot;][22]</span></code>). Obige Syntax mit <code class="docutils literal notranslate"><span class="pre">loc</span></code> ist diesen sog. ‚Äûchained assignments‚Äú (etwa: Kettenaufgabe) jedoch vorzuziehen.</p>
<p>Wie immer k√∂nnen wir auch Listen √ºbergeben, um auf mehrere Spalten und/oder mehrere Zeilen gleichzeitig zuzugreifen. Beim Zeilenzugriff funktioniert sowohl eine Liste einzelner Indizes‚Ä¶</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">songkorpus</span><span class="o">.</span><span class="n">loc</span><span class="p">[[</span><span class="mi">9999</span><span class="p">,</span><span class="mi">10000</span><span class="p">],</span> <span class="p">[</span><span class="s2">&quot;Token&quot;</span><span class="p">,</span> <span class="s2">&quot;H√§ufigkeit&quot;</span><span class="p">]]</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html"><div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Token</th>
      <th>H√§ufigkeit</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>9999</th>
      <td>Atzenlogo</td>
      <td>2</td>
    </tr>
    <tr>
      <th>10000</th>
      <td>Atzenmusik</td>
      <td>1</td>
    </tr>
  </tbody>
</table>
</div></div></div>
</div>
<p>‚Ä¶als auch die slicing√§hnliche Syntax f√ºr eine Sequenz an Zeilen:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">songkorpus</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="mi">9999</span><span class="p">:</span><span class="mi">10005</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;Token&quot;</span><span class="p">,</span> <span class="s2">&quot;H√§ufigkeit&quot;</span><span class="p">]]</span> 
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html"><div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Token</th>
      <th>H√§ufigkeit</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>9999</th>
      <td>Atzenlogo</td>
      <td>2</td>
    </tr>
    <tr>
      <th>10000</th>
      <td>Atzenmusik</td>
      <td>1</td>
    </tr>
    <tr>
      <th>10001</th>
      <td>Atzenparty</td>
      <td>4</td>
    </tr>
    <tr>
      <th>10002</th>
      <td>Atzenstyle</td>
      <td>2</td>
    </tr>
    <tr>
      <th>10003</th>
      <td>Atzentanz</td>
      <td>1</td>
    </tr>
    <tr>
      <th>10004</th>
      <td>Atzin</td>
      <td>12</td>
    </tr>
    <tr>
      <th>10005</th>
      <td>Au</td>
      <td>2</td>
    </tr>
  </tbody>
</table>
</div></div></div>
</div>
<p>Nun wissen wir, wie wir auf beliebige (Kombinationen) von Spalte(n) und Zeile(n) zugreifen k√∂nnen. Als N√§chstes m√∂chten wir unseren Daten erweitern, indem wir eine Spalte hinzuf√ºgen:</p>
</section>
<section id="spalten-hinzufugen">
<h2>Spalten hinzuf√ºgen<a class="headerlink" href="#spalten-hinzufugen" title="Permalink to this heading">#</a></h2>
<p>Eine einzelne Spalte entspricht ja einer Series und Series wiederum kommen Listen sehr nahe. Deshalb k√∂nnen wir zur Definition einer neuen Spalte ganz einfach eine Liste √ºbergeben, deren L√§nge nat√ºrlich der Anzahl an Zeilen des DataFrames entsprechen muss.</p>
<p>Sagen wir, wir h√§tten gerne eine neue Spalte, in der das Jahrzehnt gespeichert wird, in der das jeweilige Token gesungen wurde. Die einzelnen Jahre haben wir schon, nun wollen wir aber jeweils zehn Jahre zu einem Jahrzehnt b√ºndeln.</p>
<p>Dazu k√∂nnen wir in gewohnter Python-Manier √ºber die Spalte ‚ÄûJahr‚Äú in <code class="docutils literal notranslate"><span class="pre">songkorpus</span></code> iterieren (auch bei der Iteration zieht die Analogie Series ‚Äì Liste!), auf den jeweiligen Wert in der Spalte ‚ÄûJahr‚Äú zugreifen, ihn in einen string casten und das Jahr reduziert auf das Jahrzehnt einer neuen Liste anh√§ngen:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">decades</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">year</span> <span class="ow">in</span> <span class="n">songkorpus</span><span class="p">[</span><span class="s2">&quot;Jahr&quot;</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Casten in einen string ist erforderlich, da sich Slicing nur auf sequentielle Objekte anwenden l√§sst </span>
<span class="sd">    (Ganzzahlen geh√∂ren nicht dazu, vgl. zweites Notebook) und nur strings miteinander konkateniert werden k√∂nnen.&quot;&quot;&quot;</span>
    <span class="n">decade</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">year</span><span class="p">)[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="s2">&quot;0&quot;</span>
    <span class="n">decades</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">decade</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Anschlie√üend m√ºssen wir nur noch eine neue Spalte in <code class="docutils literal notranslate"><span class="pre">songkorpus</span></code> definieren und ihr die Liste <code class="docutils literal notranslate"><span class="pre">decades</span></code> zuweisen. Das Erstellen einer neuen Spalte erfolgt genau gleich wie das Definieren eines neuen Schl√ºssels bei einem dictionary:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">songkorpus</span><span class="p">[</span><span class="s2">&quot;Jahrzehnt&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">decades</span>
<span class="n">songkorpus</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html"><div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Token</th>
      <th>Jahr</th>
      <th>H√§ufigkeit</th>
      <th>Jahrzehnt</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>Klaround</td>
      <td>2007</td>
      <td>1</td>
      <td>2000</td>
    </tr>
    <tr>
      <th>1</th>
      <td>#3</td>
      <td>2009</td>
      <td>1</td>
      <td>2000</td>
    </tr>
    <tr>
      <th>2</th>
      <td>#Babo</td>
      <td>2015</td>
      <td>1</td>
      <td>2010</td>
    </tr>
    <tr>
      <th>3</th>
      <td>#JeSuisPass√©ChezSo</td>
      <td>2018</td>
      <td>1</td>
      <td>2010</td>
    </tr>
    <tr>
      <th>4</th>
      <td>#Nachbar</td>
      <td>2016</td>
      <td>1</td>
      <td>2010</td>
    </tr>
  </tbody>
</table>
</div></div></div>
</div>
<p>Recht simpel.</p>
<hr class="docutils" />
<p>‚úèÔ∏è <strong>√úbung 4:</strong></p>
<p>F√ºge <code class="docutils literal notranslate"><span class="pre">songkorpus</span></code> eine weitere Spalte mit dem Namen ‚ÄûL√§nge‚Äú hinzu, in der die Anzahl Buchstaben je Token steht.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1">#In diese Zelle kannst Du den Code zur √úbung schreiben</span>
</pre></div>
</div>
</div>
</div>
<hr class="docutils" />
<p>‚úèÔ∏è <strong>√úbung 5:</strong> Vereinfache den Code von oben, mit dessen Hilfe wir die Spalte ‚ÄûJahrzehnt‚Äú hinzugef√ºgt haben, indem Du ihn mittels List Comprehension (vgl. viertes Notebook) auf eine einzige Zeile reduzierst. Hole den Abschnitt zu List Comprehensions nach, falls Du ihn damals ausgelassen hast, da er als fortgeschritten markiert war.</p>
<p>Hinweis: <code class="docutils literal notranslate"><span class="pre">songkorpus</span></code> verf√ºgt ja bereits √ºber eine Spalte mit dem Namen ‚ÄûJahrzehnt‚Äú. Indem Du das Resultat Deiner List Comprehension <code class="docutils literal notranslate"><span class="pre">songkorpus[&quot;Jahrzehnt&quot;]</span></code> zuweist, √ºberschreibst du die befindliche Spalte ganz einfach.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1">#In diese Zelle kannst Du den Code zur √úbung schreiben</span>
</pre></div>
</div>
</div>
</div>
<hr class="docutils" />
<p>Sehr gut. Zus√§tzlich zum klassischen <code class="docutils literal notranslate"><span class="pre">for</span></code>-Loop und der List Comprehension lernen wir weiter unten eine dritte, pandas-eigene Methode kennen, mit der wir den modifizierten Inhalt einer Spalte in eine andere schreiben k√∂nnen.</p>
<p>Schauen wir uns nun an, wie wir Zeilen zu einem DataFrame hinzuf√ºgen k√∂nnen.</p>
</section>
<section id="zeilen-hinzufugen">
<h2>Zeilen hinzuf√ºgen<a class="headerlink" href="#zeilen-hinzufugen" title="Permalink to this heading">#</a></h2>
<p>Auch neue Zeilen k√∂nnen wir einem DataFrame als Liste hinzuf√ºgen. Die L√§nge der Liste muss wiederum der Anzahl an Spalten entsprechen.</p>
<p>Dies ist bei <code class="docutils literal notranslate"><span class="pre">new_row</span></code> in der n√§chsten Zelle nur der Fall, wenn Du in der √úbung oben eine f√ºnfte Spalte namens ‚ÄûL√§nge‚Äú hinzugef√ºgt hast. Um sicherzustellen, dass <code class="docutils literal notranslate"><span class="pre">songkorpus</span></code> im Weiteren alle notwendigen Spalten umfasst, f√ºgt die erste Zeile die Spalte ‚ÄûL√§nge‚Äú mittels List Comprension hinzu (bzw. √ºberschreibt eine bereits vorhandene).</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">songkorpus</span><span class="p">[</span><span class="s2">&quot;L√§nge&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">token</span><span class="p">))</span> <span class="k">for</span> <span class="n">token</span> <span class="ow">in</span> <span class="n">songkorpus</span><span class="p">[</span><span class="s2">&quot;Token&quot;</span><span class="p">]]</span>
<span class="n">new_row</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;Fantasiewort&quot;</span><span class="p">,</span> <span class="mi">2023</span><span class="p">,</span> <span class="mi">800</span><span class="p">,</span> <span class="mi">2020</span><span class="p">,</span> <span class="mi">12</span><span class="p">]</span>
</pre></div>
</div>
</div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">new_row</span></code> k√∂nnen wir <code class="docutils literal notranslate"><span class="pre">songkorpus</span></code> nun unter Verwendung der bereits bekannten <code class="docutils literal notranslate"><span class="pre">.loc[index]</span></code>-Syntax hinzuf√ºgen. Als <code class="docutils literal notranslate"><span class="pre">index</span></code> geben wir schlicht den letzten numerischen Index + 1 an, was der L√§nge von <code class="docutils literal notranslate"><span class="pre">songkorpus</span></code> entspricht (die numerischen Indizes fangen ja bei 0 an):</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">songkorpus</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">songkorpus</span><span class="p">)]</span> <span class="o">=</span> <span class="n">new_row</span>
<span class="n">songkorpus</span><span class="o">.</span><span class="n">tail</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html"><div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Token</th>
      <th>Jahr</th>
      <th>H√§ufigkeit</th>
      <th>Jahrzehnt</th>
      <th>L√§nge</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>386506</th>
      <td>ÔªøWas</td>
      <td>2020</td>
      <td>1</td>
      <td>2020</td>
      <td>4</td>
    </tr>
    <tr>
      <th>386507</th>
      <td>ÔªøWei√üer</td>
      <td>2020</td>
      <td>1</td>
      <td>2020</td>
      <td>7</td>
    </tr>
    <tr>
      <th>386508</th>
      <td>ÔªøWie</td>
      <td>2020</td>
      <td>1</td>
      <td>2020</td>
      <td>4</td>
    </tr>
    <tr>
      <th>386509</th>
      <td>ÔªøWozu</td>
      <td>2020</td>
      <td>1</td>
      <td>2020</td>
      <td>5</td>
    </tr>
    <tr>
      <th>386510</th>
      <td>Fantasiewort</td>
      <td>2023</td>
      <td>800</td>
      <td>2020</td>
      <td>12</td>
    </tr>
  </tbody>
</table>
</div></div></div>
</div>
<p>Wenn Du diese Zelle mehrfach ausf√ºhrst, wird <code class="docutils literal notranslate"><span class="pre">new_row</span></code> jedes einzelne Mal hinzugef√ºgt. Schlie√ülich entspricht <code class="docutils literal notranslate"><span class="pre">len(songkorpus)</span></code> jedes Mal dem letzten numerischen Index + 1.</p>
<p>Anstatt eine Zeile am Ende eines DataFrames hinzuzuf√ºgen, kannst Du die gleiche Syntax verwenden, um eine bestimmte, bereits existierende Zeile zu √ºberschreiben. Das tun wir hier aber nicht, da wir mit den originalen Daten weiterarbeiten m√∂chten. Entsprechend wollen wir die letzte(n) Zeile(n) mit Fantasiew√∂rtern auch wieder entfernen.</p>
</section>
<section id="spalten-und-zeilen-entfernen">
<h2>Spalten und Zeilen entfernen<a class="headerlink" href="#spalten-und-zeilen-entfernen" title="Permalink to this heading">#</a></h2>
<p>Zu diesem Zweck gibt es die <code class="docutils literal notranslate"><span class="pre">drop</span></code>-Methode, die wir sowohl zum Entfernen von Spalten als auch Zeilen benutzen k√∂nnen. Als erstes Argument √ºbergeben wir ihr den Namen der zu entfernenden Spalte bzw. den numerischen Index (oder Namen, s.o.) der zu entfernenden Zeile. Um mehrere Spalten oder Zeilen zu entfernen, k√∂nnen jeweils auch Listen √ºbergeben werden. Anschlie√üend spezifizieren wir mithilfe des <code class="docutils literal notranslate"><span class="pre">axis</span></code>-Parameters, ob es sich um eine Spalte oder eine Zeile handelt, die entfernt werden soll. <code class="docutils literal notranslate"><span class="pre">axis=1</span></code> steht f√ºr Spalten und <code class="docutils literal notranslate"><span class="pre">axis=0</span></code> f√ºr Zeilen (was der Standardwert ist und nicht zwingend angegeben werden muss). Die Syntax mit Standardwerten lautet also folgenderma√üen:</p>
<p><code class="docutils literal notranslate"><span class="pre">DataFrame.drop(index_or_name,</span> <span class="pre">axis=0)</span></code></p>
<hr class="docutils" />
<p>‚úèÔ∏è <strong>√úbung 6:</strong> F√ºhre die Zelle oben, in der wir <code class="docutils literal notranslate"><span class="pre">songkorpus</span></code> Zeilen mit Fantasiew√∂rtern hinzugef√ºgt haben, noch ein paar Mal aus, ohne darauf zu achten wie oft. Verwende nun <code class="docutils literal notranslate"><span class="pre">drop</span></code> in einer geeigneten Kontrollstruktur (vgl. drittes Notebook) sowie die anfangs eingef√ºhrte Variable <code class="docutils literal notranslate"><span class="pre">original_len</span></code>, um die Fantasiew√∂rter wieder zu entfernen und <code class="docutils literal notranslate"><span class="pre">songkorpus</span></code>, was die Anzahl an Zeilen betrifft, wieder in seinen Originalzustand zu bringen.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1">#In diese Zelle kannst Du den Code zur √úbung schreiben</span>
</pre></div>
</div>
</div>
</div>
<hr class="docutils" />
<p>Wunderbar!</p>
</section>
<section id="deskriptive-statistiken">
<h2>Deskriptive Statistiken<a class="headerlink" href="#deskriptive-statistiken" title="Permalink to this heading">#</a></h2>
<p>Einige der Spalten in <code class="docutils literal notranslate"><span class="pre">songkorpus</span></code> enthalten ja numerische Werte, konkret die Spalten ‚ÄûJahr‚Äú, ‚ÄûH√§ufigkeit‚Äú und ‚ÄûL√§nge‚Äú (die Werte in ‚ÄûJahrzehnt‚Äú haben wir als string abgespeichert, s.o.). Numerischen Werten n√§hern wir uns am besten √ºber despriptive Statistiken, also etwa √ºber Minimal- und Maximalwerte.</p>
<p>Pandas bietet daf√ºr eine Reihe n√ºtzlicher Methoden: Angewandt auf eine Spalte, gibt <code class="docutils literal notranslate"><span class="pre">min</span></code> den kleinsten Wert darin zur√ºck, <code class="docutils literal notranslate"><span class="pre">max</span></code> den gr√∂√üten, <code class="docutils literal notranslate"><span class="pre">mean</span></code> den Durchschnitt, <code class="docutils literal notranslate"><span class="pre">median</span></code> den Median und <code class="docutils literal notranslate"><span class="pre">sum</span></code> die Summe aller Werte.</p>
<p>Bevor wir dies tun, stellen wir noch sicher, dass die oben hinzugef√ºgten Zeilen auch wirklich nicht mehr vorhanden sind, schlie√ülich soll das achthundertfach vorkommende ‚ÄûFantasiewort‚Äú unsere Statistiken nicht verzerren. Anstatt mit der <code class="docutils literal notranslate"><span class="pre">drop</span></code>-Methode von oben, w√§hlen wir hier einen anderen Weg, n√§mlich Slicing:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">songkorpus</span> <span class="o">=</span> <span class="n">songkorpus</span><span class="p">[:</span><span class="n">original_len</span><span class="p">]</span>

<span class="nb">print</span><span class="p">(</span><span class="n">songkorpus</span><span class="p">[</span><span class="s2">&quot;H√§ufigkeit&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">())</span>
<span class="nb">print</span><span class="p">(</span><span class="n">songkorpus</span><span class="p">[</span><span class="s2">&quot;H√§ufigkeit&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>
<span class="nb">print</span><span class="p">(</span><span class="n">songkorpus</span><span class="p">[</span><span class="s2">&quot;H√§ufigkeit&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">())</span>
<span class="nb">print</span><span class="p">(</span><span class="n">songkorpus</span><span class="p">[</span><span class="s2">&quot;H√§ufigkeit&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">median</span><span class="p">())</span>
<span class="nb">print</span><span class="p">(</span><span class="n">songkorpus</span><span class="p">[</span><span class="s2">&quot;H√§ufigkeit&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>1
2007
5.7299293679335594
1.0
2214675
</pre></div>
</div>
</div>
</div>
<p>Wenig √ºberraschend ist 1 der kleinste Wert in der Spalte ‚ÄûH√§ufigkeit‚Äú. W√∂rter, die gar nie vorkommen, befinden sich ja nicht im Datensatz.</p>
<p>Spannend ist jedoch, zu erfahren, dass das meistgesungene Token 2007 Mal in einen bestimmten Jahr vorkommt. Interessant ist auch, dass der Durchschnitt zwar bei fast 6 Nennungen liegt, mindestens die H√§lfte aller Werte jedoch genau 1 sind. Der Median ist ja der Wert, der genau in der Mitte aller ‚Äûaufgereihten‚Äú Werte steht: links von ihm k√∂nnen also nur weitere Einsen stehen, in der Mitte steht selbst auch eine 1. Diese Logik funktioniert nat√ºrlich nur, weil wir wissen, dass alle Werte in dieser Spalte Ganzzahlen sind.</p>
<p>Einen kompakten √úberblick √ºber diese und ein paar weitere Statistiken liefert auch <code class="docutils literal notranslate"><span class="pre">describe</span></code>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">songkorpus</span><span class="p">[</span><span class="s2">&quot;H√§ufigkeit&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">describe</span><span class="p">()</span> <span class="c1">#entgegen ihrer Bezeichnung liefert describe auch die nicht-deskriptive, sondern inferentielle Standardabweichung (std)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>count    386510.000000
mean          5.729929
std          31.514454
min           1.000000
25%           1.000000
50%           1.000000
75%           3.000000
max        2007.000000
Name: H√§ufigkeit, dtype: float64
</pre></div>
</div>
</div>
</div>
<p>Dabei lernen wir u.a., dass drei Viertel aller Tokens nur maximal drei Mal in einem bestimmten Jahr vorkommen.</p>
<p><code class="docutils literal notranslate"><span class="pre">describe</span></code> l√§sst sich nicht nur auf eine Series, sondern auch auf ein DataFrame anwenden, wobei wir die Statistiken nur bei Spalten mit numerischen Werten zur√ºckerhalten:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">songkorpus</span><span class="o">.</span><span class="n">describe</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html"><div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Jahr</th>
      <th>H√§ufigkeit</th>
      <th>L√§nge</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>count</th>
      <td>386510.000000</td>
      <td>386510.000000</td>
      <td>386510.000000</td>
    </tr>
    <tr>
      <th>mean</th>
      <td>1999.486401</td>
      <td>5.729929</td>
      <td>6.877465</td>
    </tr>
    <tr>
      <th>std</th>
      <td>15.150846</td>
      <td>31.514454</td>
      <td>2.933722</td>
    </tr>
    <tr>
      <th>min</th>
      <td>1969.000000</td>
      <td>1.000000</td>
      <td>1.000000</td>
    </tr>
    <tr>
      <th>25%</th>
      <td>1986.000000</td>
      <td>1.000000</td>
      <td>5.000000</td>
    </tr>
    <tr>
      <th>50%</th>
      <td>2002.000000</td>
      <td>1.000000</td>
      <td>6.000000</td>
    </tr>
    <tr>
      <th>75%</th>
      <td>2013.000000</td>
      <td>3.000000</td>
      <td>8.000000</td>
    </tr>
    <tr>
      <th>max</th>
      <td>2022.000000</td>
      <td>2007.000000</td>
      <td>53.000000</td>
    </tr>
  </tbody>
</table>
</div></div></div>
</div>
<p>Sehr n√ºtzlich ist auch die <code class="docutils literal notranslate"><span class="pre">value_counts</span></code>-Methode, die s√§mtliche Werte in einer Spalte ausz√§hlt und uns eine Art Frequenzw√∂rterbuch zur√ºckgibt. Die Methode liefert also genau das, was wir im f√ºnften Notebook manuell f√ºr die 100 fl√§chengr√∂√üten Gemeinden Deutschlands errechnet haben:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">songkorpus</span><span class="p">[</span><span class="s2">&quot;Jahrzehnt&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">value_counts</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>2010    109062
2000     83075
1980     65571
1990     55021
1970     50949
2020     20995
1960      1837
Name: Jahrzehnt, dtype: int64
</pre></div>
</div>
</div>
</div>
<p>Die Zehnerjahre sind dieser Auswertung zufolge am h√§ufigsten vertreten im <code class="docutils literal notranslate"><span class="pre">songkorpus</span></code>.</p>
<p>Da absolute Zahlen oft schwer miteinander zu vergleichen sind, bietet <code class="docutils literal notranslate"><span class="pre">value_counts</span></code> auch die M√∂glichkeit, die Werte zu normalisieren, d.h. relativ auszugeben. Dazu spezifizieren wir ganz einfach <code class="docutils literal notranslate"><span class="pre">normalize=True</span></code>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">songkorpus</span><span class="p">[</span><span class="s2">&quot;Jahrzehnt&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">value_counts</span><span class="p">(</span><span class="n">normalize</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>2010    0.282171
2000    0.214936
1980    0.169649
1990    0.142353
1970    0.131818
2020    0.054319
1960    0.004753
Name: Jahrzehnt, dtype: float64
</pre></div>
</div>
</div>
</div>
<p>So l√§sst sich leicht ablesen, dass fast die H√§lfte aller Tokens in <code class="docutils literal notranslate"><span class="pre">songkorpus</span></code> aus den Nuller- und Zehnerjahren stammen. Dieses Ungleichgewicht m√ºssen wir bei k√ºnftigen Analysen im Hinterkopf behalten.</p>
<hr class="docutils" />
<p>‚úèÔ∏è <strong>√úbung 7:</strong> Mithilfe von <code class="docutils literal notranslate"><span class="pre">describe</span></code> haben wir oben herausgefunden, dass die durchschnittliche Wortl√§nge in <code class="docutils literal notranslate"><span class="pre">songkorpus</span></code> 6.88 Buchstaben betr√§gt. Die maximale Wortl√§nge betr√§gt hingegen sagenhafte 53 Buchstaben. Die Verteilung scheint alles andere als gleichm√§√üig zu sein, was wir auch an den sog. <em>Quartilen</em> 25% und 75% sehen (Quartile werden wie der Median berechnet, nur geht es nicht um den Mittelwert sondern um die Werte nach einem Viertel bzw. drei Vierteln aller aufgereihten Werte). Finde heraus, welche Wortl√§ngen f√ºr jeweils mindestens 10 % aller W√∂rter gelten. Finde ebenfalls heraus, welche Wortl√§ngen f√ºr jeweils maximal 1 % aller W√∂rter gelten.</p>
<p>üí° Tipp: Einer von verschiedenen denkbaren L√∂sungswegen involviert die Tatsache, dass DataFrames und Series mit dictionaries verwandt sind und sich auch in ein solches casten lassen.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1">#In diese Zelle kannst Du den Code zur √úbung schreiben</span>
</pre></div>
</div>
</div>
</div>
<hr class="docutils" />
<p>Zwei weitere hilfreiche Methoden sind <code class="docutils literal notranslate"><span class="pre">nlargest</span></code> und <code class="docutils literal notranslate"><span class="pre">nsmallest</span></code>, die das DataFrame nach einer bestimmten Spalte (spezifiziert als zweites Argument) sortieren und die <em>n</em> (spezifiziert als erstes Argument) obersten bzw. untersten Zeilen ausgibt. Folgender Code liefert also die obersten zehn Zeilen eines nach der Spalte ‚ÄûH√§ufigkeit‚Äú absteigend sortierten DataFrames:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">songkorpus</span><span class="o">.</span><span class="n">nlargest</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="s2">&quot;H√§ufigkeit&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html"><div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Token</th>
      <th>Jahr</th>
      <th>H√§ufigkeit</th>
      <th>Jahrzehnt</th>
      <th>L√§nge</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>274820</th>
      <td>ich</td>
      <td>2019</td>
      <td>2007</td>
      <td>2010</td>
      <td>3</td>
    </tr>
    <tr>
      <th>274819</th>
      <td>ich</td>
      <td>2018</td>
      <td>1788</td>
      <td>2010</td>
      <td>3</td>
    </tr>
    <tr>
      <th>274817</th>
      <td>ich</td>
      <td>2016</td>
      <td>1570</td>
      <td>2010</td>
      <td>3</td>
    </tr>
    <tr>
      <th>350154</th>
      <td>und</td>
      <td>2018</td>
      <td>1560</td>
      <td>2010</td>
      <td>3</td>
    </tr>
    <tr>
      <th>274808</th>
      <td>ich</td>
      <td>2007</td>
      <td>1513</td>
      <td>2000</td>
      <td>3</td>
    </tr>
    <tr>
      <th>274821</th>
      <td>ich</td>
      <td>2020</td>
      <td>1501</td>
      <td>2020</td>
      <td>3</td>
    </tr>
    <tr>
      <th>225263</th>
      <td>die</td>
      <td>2018</td>
      <td>1461</td>
      <td>2010</td>
      <td>3</td>
    </tr>
    <tr>
      <th>274806</th>
      <td>ich</td>
      <td>2005</td>
      <td>1455</td>
      <td>2000</td>
      <td>3</td>
    </tr>
    <tr>
      <th>350141</th>
      <td>und</td>
      <td>2005</td>
      <td>1451</td>
      <td>2000</td>
      <td>3</td>
    </tr>
    <tr>
      <th>274807</th>
      <td>ich</td>
      <td>2006</td>
      <td>1445</td>
      <td>2000</td>
      <td>3</td>
    </tr>
  </tbody>
</table>
</div></div></div>
</div>
<p>Wasser auf die M√ºhlen der Selbstbezogenheitsthese! üòÖ</p>
<p>Nat√ºrlich k√∂nnen wir ein DataFrame auch als Ganzes sortieren, anstatt blo√ü die <em>n</em> obersten bzw. untersten Zeilen zur√ºckzukriegen.</p>
</section>
<section id="werte-sortieren">
<h2>Werte sortieren<a class="headerlink" href="#werte-sortieren" title="Permalink to this heading">#</a></h2>
<p>Dazu benutzen wir die Methode <code class="docutils literal notranslate"><span class="pre">sort_values</span></code>, der wir als erstes Argument die Spalte √ºbergeben, anhand derer wir sortieren wollen, und als zweites Argument die Richtung der Sortierung, wobei <code class="docutils literal notranslate"><span class="pre">ascending=True</span></code> f√ºr aufsteigend (Standardwert) und <code class="docutils literal notranslate"><span class="pre">ascending=False</span></code> f√ºr absteigend steht.</p>
<p>Folgender Code sortiert <code class="docutils literal notranslate"><span class="pre">songkorpus</span></code> aufsteigend nach der Spalte ‚ÄûJahr‚Äú:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">songkorpus</span> <span class="o">=</span> <span class="n">songkorpus</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="s2">&quot;Jahr&quot;</span><span class="p">,</span> <span class="n">ascending</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">songkorpus</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html"><div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Token</th>
      <th>Jahr</th>
      <th>H√§ufigkeit</th>
      <th>Jahrzehnt</th>
      <th>L√§nge</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>40887</th>
      <td>Ellenbogen</td>
      <td>1969</td>
      <td>1</td>
      <td>1960</td>
      <td>10</td>
    </tr>
    <tr>
      <th>203243</th>
      <td>atmen</td>
      <td>1969</td>
      <td>1</td>
      <td>1960</td>
      <td>5</td>
    </tr>
    <tr>
      <th>330263</th>
      <td>seines</td>
      <td>1969</td>
      <td>1</td>
      <td>1960</td>
      <td>6</td>
    </tr>
    <tr>
      <th>330256</th>
      <td>seinerseits</td>
      <td>1969</td>
      <td>1</td>
      <td>1960</td>
      <td>11</td>
    </tr>
    <tr>
      <th>81807</th>
      <td>Jetzt</td>
      <td>1969</td>
      <td>4</td>
      <td>1960</td>
      <td>5</td>
    </tr>
  </tbody>
</table>
</div></div></div>
</div>
<p>Nach der Verwendung von <code class="docutils literal notranslate"><span class="pre">sort_values</span></code> lohnt es sich i.d.R., den Index des DataFrames, der ja durch die Sortierung ganz durcheinander geraten ist, zur√ºckzusetzen. Dies k√∂nnen wir mithilfe von <code class="docutils literal notranslate"><span class="pre">reset_index</span></code> tun. Zus√§tzlich spezifizieren wir, dass der alte Index gel√∂scht werden soll (<code class="docutils literal notranslate"><span class="pre">drop=True</span></code>), andernfalls wird er in einer neuen Spalte gespeichert):</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">songkorpus</span> <span class="o">=</span> <span class="n">songkorpus</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">songkorpus</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html"><div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Token</th>
      <th>Jahr</th>
      <th>H√§ufigkeit</th>
      <th>Jahrzehnt</th>
      <th>L√§nge</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>Ellenbogen</td>
      <td>1969</td>
      <td>1</td>
      <td>1960</td>
      <td>10</td>
    </tr>
    <tr>
      <th>1</th>
      <td>atmen</td>
      <td>1969</td>
      <td>1</td>
      <td>1960</td>
      <td>5</td>
    </tr>
    <tr>
      <th>2</th>
      <td>seines</td>
      <td>1969</td>
      <td>1</td>
      <td>1960</td>
      <td>6</td>
    </tr>
    <tr>
      <th>3</th>
      <td>seinerseits</td>
      <td>1969</td>
      <td>1</td>
      <td>1960</td>
      <td>11</td>
    </tr>
    <tr>
      <th>4</th>
      <td>Jetzt</td>
      <td>1969</td>
      <td>4</td>
      <td>1960</td>
      <td>5</td>
    </tr>
  </tbody>
</table>
</div></div></div>
</div>
<p>W√ºrden wir den Index nicht zur√ºcksetzen, bek√§men wir beim Zeilenzugriff √ºber <code class="docutils literal notranslate"><span class="pre">loc</span></code> u.U. nicht die Ergebnisse zur√ºck, die wir erwarten. Etwa erhielten wir √ºber <code class="docutils literal notranslate"><span class="pre">songkorpus.loc[0]</span></code> nicht die erste Zeile des neuen DataFrames zur√ºck, sondern die erste Zeile des alten, unsortierten DataFrames. Das liegt daran, dass Zeilen ihre Indizes bei der Sortierung standardm√§√üig behalten. Dieses Verhalten wird verst√§ndlicher, wenn Du Dir vorstellst, Du w√ºrdest <code class="docutils literal notranslate"><span class="pre">songkorpus_labelled_rows</span></code> sortieren.</p>
<p>Wenn wir weder an der H√§ufigkeitsverteilung aller Werte in einer bestimmten Spalte (<code class="docutils literal notranslate"><span class="pre">value_counts</span></code>), noch an deren Reihenfolge (<code class="docutils literal notranslate"><span class="pre">nlargest</span></code>, <code class="docutils literal notranslate"><span class="pre">nsmallest</span></code> und <code class="docutils literal notranslate"><span class="pre">sort_values</span></code>) interessiert sind, sondern an der blo√üen Existenz eines Wertes (egal wie oft er auftritt), gibt es eine weitere praktische Methode.</p>
</section>
<section id="einzigartige-werte">
<h2>Einzigartige Werte<a class="headerlink" href="#einzigartige-werte" title="Permalink to this heading">#</a></h2>
<p>N√§mlich <code class="docutils literal notranslate"><span class="pre">unique</span></code>, das √§hnlich wie die Python-Funktion <code class="docutils literal notranslate"><span class="pre">set</span></code> (vgl. zweites Notebook) alle einzigartigen Werte in einer bestimmten Spalte zur√ºckgibt:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">songkorpus</span><span class="p">[</span><span class="s2">&quot;Jahr&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>array([1969, 1970, 1971, 1972, 1973, 1974, 1975, 1976, 1977, 1978, 1979,
       1980, 1981, 1982, 1983, 1984, 1985, 1986, 1987, 1988, 1989, 1990,
       1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001,
       2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012,
       2013, 2014, 2015, 2016, 2017, 2018, 2019, 2020, 2021, 2022])
</pre></div>
</div>
</div>
</div>
<hr class="docutils" />
<p>‚úèÔ∏è <strong>√úbung 8:</strong> Wir wissen bereits, wieviele Tokens in unserem DataFrame vorkommen, n√§mlich 386.510. Finde heraus, wieviele einzigartige Token, also Types (vgl. viertes Notebook) es gibt.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1">#In diese Zelle kannst Du den Code zur √úbung schreiben</span>
</pre></div>
</div>
</div>
</div>
</section>
<hr class="docutils" />
<section id="dataframe-filtern">
<h2>DataFrame filtern<a class="headerlink" href="#dataframe-filtern" title="Permalink to this heading">#</a></h2>
<p>Als n√§chstes wollen wir herausfinden, wie wir ein DataFrame filtern k√∂nnen. Die grundlegende Syntax sieht wie folgt aus:</p>
<p><code class="docutils literal notranslate"><span class="pre">DataFrame[filter]</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">filter</span></code> wiederum kann unterschiedlich ausschauen, je nach dem, wie wir unser DataFrame filtern wollen. Ein einfaches Beispiel f√ºr <code class="docutils literal notranslate"><span class="pre">filter</span></code> sieht so aus:</p>
<p><code class="docutils literal notranslate"><span class="pre">DataFrame[column]</span> <span class="pre">==</span> <span class="pre">value</span></code></p>
<p>Dieser Filter verlangt, dass bei <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code> in der Spalte <code class="docutils literal notranslate"><span class="pre">column</span></code> exakt der Wert <code class="docutils literal notranslate"><span class="pre">value</span></code> steht.</p>
<p>F√ºgen wir diesen Filter in der obigen Syntax ein und schaffen ein Sub-DataFrame, das alle Zeilen des <code class="docutils literal notranslate"><span class="pre">songkorpus</span></code> beinh√§lt, in denen in der Spalte <code class="docutils literal notranslate"><span class="pre">Token</span></code> das Wort ‚ÄûLiebe‚Äú steht:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">liebe</span> <span class="o">=</span> <span class="n">songkorpus</span><span class="p">[</span><span class="n">songkorpus</span><span class="p">[</span><span class="s2">&quot;Token&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;Liebe&quot;</span><span class="p">]</span>
<span class="n">liebe</span><span class="o">.</span><span class="n">head</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html"><div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Token</th>
      <th>Jahr</th>
      <th>H√§ufigkeit</th>
      <th>Jahrzehnt</th>
      <th>L√§nge</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>764</th>
      <td>Liebe</td>
      <td>1969</td>
      <td>1</td>
      <td>1960</td>
      <td>5</td>
    </tr>
    <tr>
      <th>4477</th>
      <td>Liebe</td>
      <td>1970</td>
      <td>93</td>
      <td>1970</td>
      <td>5</td>
    </tr>
    <tr>
      <th>8774</th>
      <td>Liebe</td>
      <td>1971</td>
      <td>106</td>
      <td>1970</td>
      <td>5</td>
    </tr>
    <tr>
      <th>11189</th>
      <td>Liebe</td>
      <td>1972</td>
      <td>104</td>
      <td>1970</td>
      <td>5</td>
    </tr>
    <tr>
      <th>14421</th>
      <td>Liebe</td>
      <td>1973</td>
      <td>152</td>
      <td>1970</td>
      <td>5</td>
    </tr>
  </tbody>
</table>
</div></div></div>
</div>
<p>Das klappt wunderbar. Spiel gerne mit anderen Begriffen herum.</p>
<hr class="docutils" />
<p>‚úèÔ∏è <strong>√úbung 9:</strong> Erstelle ein Sub-DataFrame, das nur Tokens beinh√§lt, die mindestes 20 Zeichen lang sind.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1">#In diese Zelle kannst Du den Code zur √úbung schreiben</span>
</pre></div>
</div>
</div>
</div>
<hr class="docutils" />
<p>Abgsehen von Vergleichsoperatoren (<code class="docutils literal notranslate"><span class="pre">==</span></code>, <code class="docutils literal notranslate"><span class="pre">!=</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;=</span></code> und <code class="docutils literal notranslate"><span class="pre">&lt;=</span></code>, vgl. erstes Notebook) bei numerischen Werten (alle Operatoren) bzw. strings (nur die ersten beiden) k√∂nnen wir bei strings auch andere Methoden in den Filter einbauen. Pandas bietet sowohl solche an, die wir bereits von gew√∂hnlichen strings kennen (vgl. viertes Notebook), als auch ein paar eigene. Wichtig ist, dass die Methoden die Boolschen Werte <code class="docutils literal notranslate"><span class="pre">True</span></code> oder <code class="docutils literal notranslate"><span class="pre">False</span></code> zur√ºckgeben. Das hei√üt, <code class="docutils literal notranslate"><span class="pre">startswith</span></code> funktioniert, <code class="docutils literal notranslate"><span class="pre">split</span></code> hingegen nicht. String-Methoden bei pandas beginnen immer mit <code class="docutils literal notranslate"><span class="pre">str</span></code>, gefolgt von der Methode, also etwa <code class="docutils literal notranslate"><span class="pre">str.startswith()</span></code>. Au√üerdem m√ºssen wir ihnen in vielen F√§llen den Paramter <code class="docutils literal notranslate"><span class="pre">na=False</span></code> √ºbergeben. Hier ein paar Beispiele:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">liebe_startswith</span> <span class="o">=</span> <span class="n">songkorpus</span><span class="p">[</span><span class="n">songkorpus</span><span class="p">[</span><span class="s2">&quot;Token&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;liebe&quot;</span><span class="p">,</span> <span class="n">na</span><span class="o">=</span><span class="kc">False</span><span class="p">)]</span> <span class="c1">#wie normale string-Methode in Python</span>
<span class="n">liebe_endswith</span> <span class="o">=</span> <span class="n">songkorpus</span><span class="p">[</span><span class="n">songkorpus</span><span class="p">[</span><span class="s2">&quot;Token&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;liebe&quot;</span><span class="p">,</span> <span class="n">na</span><span class="o">=</span><span class="kc">False</span><span class="p">)]</span> <span class="c1">#wie normale string-Methode in Python</span>
<span class="n">liebe_contains</span> <span class="o">=</span> <span class="n">songkorpus</span><span class="p">[</span><span class="n">songkorpus</span><span class="p">[</span><span class="s2">&quot;Token&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="s2">&quot;liebe&quot;</span><span class="p">,</span> <span class="n">na</span><span class="o">=</span><span class="kc">False</span><span class="p">)]</span> <span class="c1">#pandas-eigene Methode</span>

<span class="nb">print</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">liebe_startswith</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">liebe_endswith</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">liebe_contains</span><span class="p">))</span>
<span class="n">liebe_contains</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>217 108 398
</pre></div>
</div>
<div class="output text_html"><div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Token</th>
      <th>Jahr</th>
      <th>H√§ufigkeit</th>
      <th>Jahrzehnt</th>
      <th>L√§nge</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>1091</th>
      <td>Bliebe</td>
      <td>1969</td>
      <td>1</td>
      <td>1960</td>
      <td>6</td>
    </tr>
    <tr>
      <th>1743</th>
      <td>lieber</td>
      <td>1969</td>
      <td>3</td>
      <td>1960</td>
      <td>6</td>
    </tr>
    <tr>
      <th>1757</th>
      <td>liebe</td>
      <td>1969</td>
      <td>2</td>
      <td>1960</td>
      <td>5</td>
    </tr>
    <tr>
      <th>1924</th>
      <td>Bliebe</td>
      <td>1970</td>
      <td>1</td>
      <td>1970</td>
      <td>6</td>
    </tr>
    <tr>
      <th>2324</th>
      <td>bliebe</td>
      <td>1970</td>
      <td>2</td>
      <td>1970</td>
      <td>6</td>
    </tr>
    <tr>
      <th>...</th>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
    </tr>
    <tr>
      <th>381292</th>
      <td>lieber</td>
      <td>2021</td>
      <td>9</td>
      <td>2020</td>
      <td>6</td>
    </tr>
    <tr>
      <th>382420</th>
      <td>verlieben</td>
      <td>2022</td>
      <td>1</td>
      <td>2020</td>
      <td>9</td>
    </tr>
    <tr>
      <th>384346</th>
      <td>lieber</td>
      <td>2022</td>
      <td>3</td>
      <td>2020</td>
      <td>6</td>
    </tr>
    <tr>
      <th>384351</th>
      <td>lieben</td>
      <td>2022</td>
      <td>13</td>
      <td>2020</td>
      <td>6</td>
    </tr>
    <tr>
      <th>384354</th>
      <td>liebe</td>
      <td>2022</td>
      <td>17</td>
      <td>2020</td>
      <td>5</td>
    </tr>
  </tbody>
</table>
<p>398 rows √ó 5 columns</p>
</div></div></div>
</div>
<hr class="docutils" />
<p>‚úèÔ∏è <strong>√úbung 10:</strong> Erstelle das gleiche Sub-DataFrame wie in √úbung 9 (also eines, das nur Tokens beinh√§lt, die mindestes 20 Zeichen lang sind), allerdings ohne dabei die Spalte ‚ÄûL√§nge‚Äú zu bem√ºhen. Du kannst dazu eine Methode verwenden, die auch bei normalen strings funktioniert. Stelle sicher, dass die Ergebnisse der beiden √úbungen identisch sind.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1">#In diese Zelle kannst Du den Code zur √úbung schreiben</span>
</pre></div>
</div>
</div>
</div>
<hr class="docutils" />
<p>Gut zu wissen: Filter k√∂nnen auch miteinander kombiniert werden. Dazu verwenden wir die logischen Operatoren aus dem vierten Notebook, die bei pandas allerdings in einem anderen Gewand daherkommen:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">&amp;</span></code> steht f√ºr f√ºr <code class="docutils literal notranslate"><span class="pre">and</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">|</span></code> steht f√ºr <code class="docutils literal notranslate"><span class="pre">or</span></code></p></li>
</ul>
<p>Au√üerdem steht <code class="docutils literal notranslate"><span class="pre">~</span></code> steht f√ºr <code class="docutils literal notranslate"><span class="pre">not</span></code> und kann zur Negation eines einzelnen Filters benutzt werden.</p>
<p>Unter Verwendung von <code class="docutils literal notranslate"><span class="pre">&amp;</span></code> k√∂nnen wir beispielsweise alle (potentiellen) regelm√§√üigen Partizip II-Formen extrahieren:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">songkorpus</span><span class="p">[</span><span class="n">songkorpus</span><span class="p">[</span><span class="s2">&quot;Token&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;ge&quot;</span><span class="p">,</span> <span class="n">na</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">songkorpus</span><span class="p">[</span><span class="s2">&quot;Token&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;t&quot;</span><span class="p">,</span> <span class="n">na</span><span class="o">=</span><span class="kc">False</span><span class="p">)]</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html"><div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Token</th>
      <th>Jahr</th>
      <th>H√§ufigkeit</th>
      <th>Jahrzehnt</th>
      <th>L√§nge</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>334</th>
      <td>gefasst</td>
      <td>1969</td>
      <td>1</td>
      <td>1960</td>
      <td>7</td>
    </tr>
    <tr>
      <th>398</th>
      <td>gef√ºllt</td>
      <td>1969</td>
      <td>2</td>
      <td>1960</td>
      <td>7</td>
    </tr>
    <tr>
      <th>423</th>
      <td>gef√ºhlt</td>
      <td>1969</td>
      <td>1</td>
      <td>1960</td>
      <td>7</td>
    </tr>
    <tr>
      <th>469</th>
      <td>gebracht</td>
      <td>1969</td>
      <td>2</td>
      <td>1960</td>
      <td>8</td>
    </tr>
    <tr>
      <th>515</th>
      <td>geduldet</td>
      <td>1969</td>
      <td>1</td>
      <td>1960</td>
      <td>8</td>
    </tr>
    <tr>
      <th>...</th>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
    </tr>
    <tr>
      <th>385594</th>
      <td>gestresst</td>
      <td>2022</td>
      <td>2</td>
      <td>2020</td>
      <td>9</td>
    </tr>
    <tr>
      <th>385603</th>
      <td>gesagt</td>
      <td>2022</td>
      <td>4</td>
      <td>2020</td>
      <td>6</td>
    </tr>
    <tr>
      <th>385610</th>
      <td>geschafft</td>
      <td>2022</td>
      <td>3</td>
      <td>2020</td>
      <td>9</td>
    </tr>
    <tr>
      <th>385653</th>
      <td>geschleudert</td>
      <td>2022</td>
      <td>1</td>
      <td>2020</td>
      <td>12</td>
    </tr>
    <tr>
      <th>385688</th>
      <td>geschenkt</td>
      <td>2022</td>
      <td>2</td>
      <td>2020</td>
      <td>9</td>
    </tr>
  </tbody>
</table>
<p>5125 rows √ó 5 columns</p>
</div></div></div>
</div>
<p>Bedenke, dass auch falsch positive Ergebnisse dabei sein k√∂nnten sowie, dass falsch negative fehlen k√∂nnten (vgl. f√ºnftes Notebook).</p>
<p>Nun wissen wir, wie wir ein DataFrame filtern k√∂nnen.</p>
</section>
<section id="werte-zahlen">
<h2>Werte z√§hlen<a class="headerlink" href="#werte-zahlen" title="Permalink to this heading">#</a></h2>
<p>Dieses Wissen k√∂nnen wir auch einsetzen, um spezifische Werte ‚Äì im Gegensatz zu allen Werten wie bei <code class="docutils literal notranslate"><span class="pre">value_counts</span></code> oben ‚Äì in einer Spalte auszuz√§hlen:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">len</span><span class="p">(</span><span class="n">songkorpus</span><span class="p">[</span><span class="n">songkorpus</span><span class="p">[</span><span class="s2">&quot;Token&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;Wunderkind&quot;</span><span class="p">])</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>5
</pre></div>
</div>
</div>
</div>
<p>Wir filtern also das DataFrame (‚Äûalle Zeilen, in denen ‚ÄöWunderkind‚Äò in der Spalte ‚ÄöToken‚Äò steht‚Äú) und lassen uns ganz einfach seine L√§nge (sprich die Anzahl an Zeilen) ausgeben.</p>
</section>
<section id="werte-bearbeiten">
<h2>Werte bearbeiten<a class="headerlink" href="#werte-bearbeiten" title="Permalink to this heading">#</a></h2>
<p>Auch zum Bearbeiten von Werten ben√∂tigen wir nur bereits erlerntes Wissen. Grunds√§tzlich k√∂nnen wir alles von einem kompletten DataFrame, √ºber eine Series (in Form einer Spalte oder Zeile) bis hin zu einzelnen, spezifischen Werten bearbeiten.</p>
<p>Die M√∂glichkeiten der Bearbeitung h√§ngen nat√ºrlich vom Datentyp der Werte ab. In unserem DataFrame haben wir einerseits strings und andererseits numerische Werte und Spalten weisen jeweils einen homogen Datentyp auf.</p>
<p>Die Logik ist unabh√§ngig davon, was wir wie bearbeiten, immer die gleiche: Wir greifen auf den gew√ºnschten Ausschnitt des DataFrames zu (s.o.) und √ºberschreiben ihn mit demselben Ausschnitt in bearbeiteter Form. Anstatt √úberschreiben k√∂nnen wir die bearbeiteten Werte nat√ºrlich immer auch einer neuen Spalte oder Zeile (desgleichen oder eines neuen DataFrames) zuweisen, sofern die jeweiligen Dimensionen √ºbereinstimmen  (s.o.).</p>
<section id="strings">
<h3>Strings<a class="headerlink" href="#strings" title="Permalink to this heading">#</a></h3>
<p>Auf strings angewandt, sieht das so aus, wenn wir etwa alle Tokens kleinschreiben wollen. Auch hier setzen wir <code class="docutils literal notranslate"><span class="pre">str</span></code> vor die pandas-string-Methode:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">songkorpus</span><span class="p">[</span><span class="s2">&quot;Token&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">songkorpus</span><span class="p">[</span><span class="s2">&quot;Token&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
<span class="n">songkorpus</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html"><div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Token</th>
      <th>Jahr</th>
      <th>H√§ufigkeit</th>
      <th>Jahrzehnt</th>
      <th>L√§nge</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>ellenbogen</td>
      <td>1969</td>
      <td>1</td>
      <td>1960</td>
      <td>10</td>
    </tr>
    <tr>
      <th>1</th>
      <td>atmen</td>
      <td>1969</td>
      <td>1</td>
      <td>1960</td>
      <td>5</td>
    </tr>
    <tr>
      <th>2</th>
      <td>seines</td>
      <td>1969</td>
      <td>1</td>
      <td>1960</td>
      <td>6</td>
    </tr>
    <tr>
      <th>3</th>
      <td>seinerseits</td>
      <td>1969</td>
      <td>1</td>
      <td>1960</td>
      <td>11</td>
    </tr>
    <tr>
      <th>4</th>
      <td>jetzt</td>
      <td>1969</td>
      <td>4</td>
      <td>1960</td>
      <td>5</td>
    </tr>
    <tr>
      <th>...</th>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
    </tr>
    <tr>
      <th>386505</th>
      <td>uhh</td>
      <td>2022</td>
      <td>2</td>
      <td>2020</td>
      <td>3</td>
    </tr>
    <tr>
      <th>386506</th>
      <td>amate</td>
      <td>2022</td>
      <td>1</td>
      <td>2020</td>
      <td>5</td>
    </tr>
    <tr>
      <th>386507</th>
      <td>schlief</td>
      <td>2022</td>
      <td>6</td>
      <td>2020</td>
      <td>7</td>
    </tr>
    <tr>
      <th>386508</th>
      <td>uhren</td>
      <td>2022</td>
      <td>2</td>
      <td>2020</td>
      <td>5</td>
    </tr>
    <tr>
      <th>386509</th>
      <td>bladis</td>
      <td>2022</td>
      <td>3</td>
      <td>2020</td>
      <td>6</td>
    </tr>
  </tbody>
</table>
<p>386510 rows √ó 5 columns</p>
</div></div></div>
</div>
<p>Diese einzeilige Syntax hat es in sich: Man kann sie sich in gewohnter Python-Logik wie eine Iteration vorstellen: Im vorliegenden Fall wird Wort f√ºr Wort (in der Spalte ‚ÄûToken‚Äú) kleingeschrieben. Mit dem Resultat wird die Spalte √ºberschrieben. Sie ist dennoch nicht mit einer List Comprehension, die ja auch nur eine einzige Zeile ben√∂tigt, zu verwechseln. Denn im Gegensatz zu pythonischen <code class="docutils literal notranslate"><span class="pre">for</span></code>-Loops und ihre simplifizierte Version List Comprehension, wird der Code mit der pandas-eigenen Syntax oft wesentlich schneller berechnet (teils √ºber 1000 Mal schneller!). Grund daf√ºr ist die sog. <em>Vektorisierung</em>. Ganz einfach forumuliert wird dabei dieselbe Operation nicht auf ein Element nach dem anderen angewandt (wie bei <code class="docutils literal notranslate"><span class="pre">for</span></code>-Loops), sondern auf mehrere gleichzeitig. Au√üerdem sind pandas-Operationen im Gegensatz zu nativem Python-Code (<code class="docutils literal notranslate"><span class="pre">for</span></code>-Loops) speziell auf Effizienz ausgelegt. Wenn Du Dich daf√ºr interessierst, findest Du u.a. in <a class="reference external" href="https://medium.com/analytics-vidhya/understanding-vectorization-in-numpy-and-pandas-188b6ebc5398">diesem Artikel</a> und <a class="reference external" href="https://www.youtube.com/watch?v=nxWginnBklU">diesem Video</a> Ankn√ºpfungspunkte. Weiter unten folgen √úbungen zum Vergleich von nativem Python-Code und pandas-Code.</p>
<p>Zus√§tzlich zu den bisher verwendeten string-Methoden <code class="docutils literal notranslate"><span class="pre">lower</span></code>, <code class="docutils literal notranslate"><span class="pre">startswith</span></code>, <code class="docutils literal notranslate"><span class="pre">endswith</span></code> und <code class="docutils literal notranslate"><span class="pre">len</span></code> bietet pandas u.a. folgende an, die allesamt wie ihre nativen Python-Pendants funktionieren (vgl. viertes Notebook):</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">upper</span></code>, <code class="docutils literal notranslate"><span class="pre">capitalize</span></code>, <code class="docutils literal notranslate"><span class="pre">swapcase</span></code>, <code class="docutils literal notranslate"><span class="pre">isupper</span></code> und <code class="docutils literal notranslate"><span class="pre">islower</span></code> zur Bearbeitung/√úberpr√ºfung von Gro√ü-/Kleinschreibung der strings.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">split</span></code> zum Splitten der strings, optional mit dem Parameter <code class="docutils literal notranslate"><span class="pre">expand=True</span></code>, um jedem unterteilten Element eine neue Spalte zuzuweisen.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">replace</span></code> zum Ersetzen aller Vorkommen eines strings/regul√§ren Ausdrucks (hier zus√§tzlich <code class="docutils literal notranslate"><span class="pre">regex=True</span></code> spezifizieren) mit einem anderen string.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">count</span></code> zum Berechnen der Auftretensh√§ufigkeit eines strings/regul√§ren Ausdrucks in den strings.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">strip</span></code>, <code class="docutils literal notranslate"><span class="pre">lstrip</span></code> und <code class="docutils literal notranslate"><span class="pre">rstrip</span></code> zum Entfernen von (leading/trailing) whitespace in den strings.</p></li>
</ul>
<p>Neben <code class="docutils literal notranslate"><span class="pre">contains</span></code> (s.o.) ist au√üerdem <code class="docutils literal notranslate"><span class="pre">slice</span></code> eine n√ºtzliche pandas-string-Methode, die abweichend von ihrem nativen Python-Pendant hei√üt: <code class="docutils literal notranslate"><span class="pre">slice</span></code> mit den Argumentenen <code class="docutils literal notranslate"><span class="pre">start</span></code>, <code class="docutils literal notranslate"><span class="pre">stop</span></code>, <code class="docutils literal notranslate"><span class="pre">step</span></code> implementiert die Funktionalit√§t der eckigen Klammern, die wir bei normalen Python-strings zum Slicen verwenden.</p>
<p><a class="reference external" href="https://pandas.pydata.org/docs/user_guide/text.html">Hier</a> findest Du mehr Infos zu s√§mlichen string-Methoden bei pandas. Denke stets daran, <code class="docutils literal notranslate"><span class="pre">str</span></code> vor die jeweilige string-Methode zu h√§ngen!</p>
<p>Eine letzte praktische Methode ist <code class="docutils literal notranslate"><span class="pre">isin(list)</span></code>. Sie √ºberpr√ºft, ob ein Wert Element der √ºbergebenen Liste ist und gibt eine Series mit Boolschen Werten zur√ºck. <code class="docutils literal notranslate"><span class="pre">isin</span></code> l√§sst nicht nur bei strings anwenden, deshalb h√§ngen wir auch kein <code class="docutils literal notranslate"><span class="pre">str</span></code> davor.</p>
</section>
<section id="numerische-werte">
<h3>Numerische Werte<a class="headerlink" href="#numerische-werte" title="Permalink to this heading">#</a></h3>
<p>Bei numerischen Werten wiederum k√∂nnen wir ganz einfach arithmetische Operatoren (vgl. erstes Notebook) verwenden, etwa um alle Werte einer Spalte zu verdoppeln:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1">#f√ºhre diese Zeile nur einmal aus, denn mit jedem Mal verdoppeln sich die Werte</span>
<span class="n">songkorpus</span><span class="p">[</span><span class="s2">&quot;H√§ufigkeit&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">songkorpus</span><span class="p">[</span><span class="s2">&quot;H√§ufigkeit&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="mi">2</span>
<span class="n">songkorpus</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html"><div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Token</th>
      <th>Jahr</th>
      <th>H√§ufigkeit</th>
      <th>Jahrzehnt</th>
      <th>L√§nge</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>ellenbogen</td>
      <td>1969</td>
      <td>2</td>
      <td>1960</td>
      <td>10</td>
    </tr>
    <tr>
      <th>1</th>
      <td>atmen</td>
      <td>1969</td>
      <td>2</td>
      <td>1960</td>
      <td>5</td>
    </tr>
    <tr>
      <th>2</th>
      <td>seines</td>
      <td>1969</td>
      <td>2</td>
      <td>1960</td>
      <td>6</td>
    </tr>
    <tr>
      <th>3</th>
      <td>seinerseits</td>
      <td>1969</td>
      <td>2</td>
      <td>1960</td>
      <td>11</td>
    </tr>
    <tr>
      <th>4</th>
      <td>jetzt</td>
      <td>1969</td>
      <td>8</td>
      <td>1960</td>
      <td>5</td>
    </tr>
    <tr>
      <th>...</th>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
    </tr>
    <tr>
      <th>386505</th>
      <td>uhh</td>
      <td>2022</td>
      <td>4</td>
      <td>2020</td>
      <td>3</td>
    </tr>
    <tr>
      <th>386506</th>
      <td>amate</td>
      <td>2022</td>
      <td>2</td>
      <td>2020</td>
      <td>5</td>
    </tr>
    <tr>
      <th>386507</th>
      <td>schlief</td>
      <td>2022</td>
      <td>12</td>
      <td>2020</td>
      <td>7</td>
    </tr>
    <tr>
      <th>386508</th>
      <td>uhren</td>
      <td>2022</td>
      <td>4</td>
      <td>2020</td>
      <td>5</td>
    </tr>
    <tr>
      <th>386509</th>
      <td>bladis</td>
      <td>2022</td>
      <td>6</td>
      <td>2020</td>
      <td>6</td>
    </tr>
  </tbody>
</table>
<p>386510 rows √ó 5 columns</p>
</div></div></div>
</div>
<p>Hierf√ºr funktionieren auch die anderen uns bekannten arithmetischen Operatoren: <code class="docutils literal notranslate"><span class="pre">+</span></code> f√ºr Addition (eignet sich √ºberdies zur Konkatenation von strings), <code class="docutils literal notranslate"><span class="pre">-</span></code> f√ºr Subtraktion,  <code class="docutils literal notranslate"><span class="pre">/</span></code> f√ºr Division und <code class="docutils literal notranslate"><span class="pre">**</span></code> f√ºrs Potenzieren.</p>
</section>
<section id="datentyp-andern">
<h3>Datentyp √§ndern<a class="headerlink" href="#datentyp-andern" title="Permalink to this heading">#</a></h3>
<p>Sollten Werte mal im falschen Datentyp vorliegen, kann man (sofern sinnvoll) die Methode <code class="docutils literal notranslate"><span class="pre">astype</span></code> verwenden, um Werte in den gew√ºnschten Datentyp zu casten. Wenn wir z.B. die H√§ufigkeiten wieder in den Originalzustand versetzen wollen, k√∂nnen wir erst alle Werte in der entsprechenden Spalte halbieren‚Ä¶</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">songkorpus</span><span class="p">[</span><span class="s2">&quot;H√§ufigkeit&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">songkorpus</span><span class="p">[</span><span class="s2">&quot;H√§ufigkeit&quot;</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span>
<span class="n">songkorpus</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html"><div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Token</th>
      <th>Jahr</th>
      <th>H√§ufigkeit</th>
      <th>Jahrzehnt</th>
      <th>L√§nge</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>ellenbogen</td>
      <td>1969</td>
      <td>1.0</td>
      <td>1960</td>
      <td>10</td>
    </tr>
    <tr>
      <th>1</th>
      <td>atmen</td>
      <td>1969</td>
      <td>1.0</td>
      <td>1960</td>
      <td>5</td>
    </tr>
    <tr>
      <th>2</th>
      <td>seines</td>
      <td>1969</td>
      <td>1.0</td>
      <td>1960</td>
      <td>6</td>
    </tr>
    <tr>
      <th>3</th>
      <td>seinerseits</td>
      <td>1969</td>
      <td>1.0</td>
      <td>1960</td>
      <td>11</td>
    </tr>
    <tr>
      <th>4</th>
      <td>jetzt</td>
      <td>1969</td>
      <td>4.0</td>
      <td>1960</td>
      <td>5</td>
    </tr>
    <tr>
      <th>...</th>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
    </tr>
    <tr>
      <th>386505</th>
      <td>uhh</td>
      <td>2022</td>
      <td>2.0</td>
      <td>2020</td>
      <td>3</td>
    </tr>
    <tr>
      <th>386506</th>
      <td>amate</td>
      <td>2022</td>
      <td>1.0</td>
      <td>2020</td>
      <td>5</td>
    </tr>
    <tr>
      <th>386507</th>
      <td>schlief</td>
      <td>2022</td>
      <td>6.0</td>
      <td>2020</td>
      <td>7</td>
    </tr>
    <tr>
      <th>386508</th>
      <td>uhren</td>
      <td>2022</td>
      <td>2.0</td>
      <td>2020</td>
      <td>5</td>
    </tr>
    <tr>
      <th>386509</th>
      <td>bladis</td>
      <td>2022</td>
      <td>3.0</td>
      <td>2020</td>
      <td>6</td>
    </tr>
  </tbody>
</table>
<p>386510 rows √ó 5 columns</p>
</div></div></div>
</div>
<p>‚Ä¶und, da Resultat einer Division immer Dezimalzahlen sind (s. Nachkommastelle), anschlie√üend in Ganzzahlen casten:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">songkorpus</span><span class="p">[</span><span class="s2">&quot;H√§ufigkeit&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">songkorpus</span><span class="p">[</span><span class="s2">&quot;H√§ufigkeit&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
<span class="n">songkorpus</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html"><div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Token</th>
      <th>Jahr</th>
      <th>H√§ufigkeit</th>
      <th>Jahrzehnt</th>
      <th>L√§nge</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>ellenbogen</td>
      <td>1969</td>
      <td>1</td>
      <td>1960</td>
      <td>10</td>
    </tr>
    <tr>
      <th>1</th>
      <td>atmen</td>
      <td>1969</td>
      <td>1</td>
      <td>1960</td>
      <td>5</td>
    </tr>
    <tr>
      <th>2</th>
      <td>seines</td>
      <td>1969</td>
      <td>1</td>
      <td>1960</td>
      <td>6</td>
    </tr>
    <tr>
      <th>3</th>
      <td>seinerseits</td>
      <td>1969</td>
      <td>1</td>
      <td>1960</td>
      <td>11</td>
    </tr>
    <tr>
      <th>4</th>
      <td>jetzt</td>
      <td>1969</td>
      <td>4</td>
      <td>1960</td>
      <td>5</td>
    </tr>
    <tr>
      <th>...</th>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
    </tr>
    <tr>
      <th>386505</th>
      <td>uhh</td>
      <td>2022</td>
      <td>2</td>
      <td>2020</td>
      <td>3</td>
    </tr>
    <tr>
      <th>386506</th>
      <td>amate</td>
      <td>2022</td>
      <td>1</td>
      <td>2020</td>
      <td>5</td>
    </tr>
    <tr>
      <th>386507</th>
      <td>schlief</td>
      <td>2022</td>
      <td>6</td>
      <td>2020</td>
      <td>7</td>
    </tr>
    <tr>
      <th>386508</th>
      <td>uhren</td>
      <td>2022</td>
      <td>2</td>
      <td>2020</td>
      <td>5</td>
    </tr>
    <tr>
      <th>386509</th>
      <td>bladis</td>
      <td>2022</td>
      <td>3</td>
      <td>2020</td>
      <td>6</td>
    </tr>
  </tbody>
</table>
<p>386510 rows √ó 5 columns</p>
</div></div></div>
</div>
<hr class="docutils" />
<p>‚úèÔ∏è <strong>√úbung 11:</strong> Oben haben wir die Spalte ‚ÄûJahrzehnt‚Äú basierend auf den Jahreszahlen mithilfe eines <code class="docutils literal notranslate"><span class="pre">for</span></code>-Loops geschaffen. Gehe abermals von der Spalte ‚ÄûJahr‚Äú aus, um eine neue Spalte ‚ÄûJahrzehnt_ohne_Loop‚Äú zu schaffen, allerdings ‚Äì wie der Name verr√§t ‚Äì ohne daf√ºr einen Loop, auch nicht in Form einer List Comprehension, zu benutzen. Mit anderen Worten: Du sollst Pandas-Syntax daf√ºr einsetzen. Wenn Dein Code stimmt, ergibt die bereits geschriebene (derzeit auskommentierte) Zeile <code class="docutils literal notranslate"><span class="pre">True</span></code>.</p>
<p>üí° Tipp: Es sind dieselben einzelnen Schritte wie im <code class="docutils literal notranslate"><span class="pre">for</span></code>-Loop oben n√∂tig, allerdings formuliert in pandas-Syntax. Gegebenfalls musst Du in der <a class="reference external" href="https://pandas.pydata.org/docs/">pandas-Dokumentation</a> nachschlagen, wie die jeweilige Syntax der pandas-Pendants ausschaut.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1">#In diese Zelle kannst Du den Code zur √úbung schreiben</span>


<span class="c1">#print(songkorpus[&quot;Jahrzehnt&quot;].equals(songkorpus[&quot;Jahrzehnt_ohne_Loop&quot;]))</span>
</pre></div>
</div>
</div>
</div>
<hr class="docutils" />
<p>Sehr gut! Die simple Iteration von oben, die s√§mtliche Werte nacheinander auf dieselbe Weise bearbeitet, k√∂nnen wir also auch ganz einfach in vektorisierter Form nachbilden.</p>
</section>
<section id="bedingte-bearbeitung">
<h3>Bedingte Bearbeitung<a class="headerlink" href="#bedingte-bearbeitung" title="Permalink to this heading">#</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">for</span></code>-Loops bieten aber nat√ºrlich viel mehr Funktionalit√§t. Etwa k√∂nnen wir bedingte Anweisungen einbauen, sodass die Werte je nach Bedingung unterschiedlich bearbeitet werden. Aber auch daf√ºr bietet pandas, oder besser gesagt <em>numpy</em> (eine weitere Bibliothek, die eng mit pandas verwoben ist) eine Funktion, die sich Vektorisierung zunutze macht. Auch numpy m√ºssen wir erst importieren (ggf. sogar noch zuerst installieren, s.o.), g√§ngigerweise weisen wir der Bibliothek den Namen <code class="docutils literal notranslate"><span class="pre">np</span></code> zu:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
</pre></div>
</div>
</div>
</div>
<p>Die Funktion hei√üt <code class="docutils literal notranslate"><span class="pre">where</span></code> und hat folgende Syntax:</p>
<p><code class="docutils literal notranslate"><span class="pre">where(if,</span> <span class="pre">then,</span> <span class="pre">else)</span></code></p>
<p>Als erstes Argument (‚Äûif‚Äú) spezifizieren wir eine bedingte Anweisung, die bei jedem Wert entweder <code class="docutils literal notranslate"><span class="pre">True</span></code> oder <code class="docutils literal notranslate"><span class="pre">False</span></code> ergibt. Im Falle von <code class="docutils literal notranslate"><span class="pre">True</span></code> wird der Wert wie im zweiten Argument (‚Äûthen‚Äú) angegeben eingetragen bzw. bearbeitet. Andernfalls greift, was wir als drittes Argument (‚Äûelse‚Äú) definiert haben.</p>
<p>Angenommen wir m√∂chten zus√§tzlich zur Spalte ‚ÄûJahrzehnt‚Äú eine Spalte ‚ÄûJahrhundert‚Äú, k√∂nnen wir <code class="docutils literal notranslate"><span class="pre">where</span></code> folgenderma√üen dazu einsetzen:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1">#vor where steht wie gewohnt der Modulname, damit Python wei√ü, wo sich die Funktion befindet</span>
<span class="n">songkorpus</span><span class="p">[</span><span class="s2">&quot;Jahrhundert&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">songkorpus</span><span class="p">[</span><span class="s2">&quot;Jahr&quot;</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">2000</span><span class="p">,</span> <span class="s2">&quot;20. Jhd.&quot;</span><span class="p">,</span> <span class="s2">&quot;21. Jhd.&quot;</span><span class="p">)</span>
<span class="n">songkorpus</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html"><div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Token</th>
      <th>Jahr</th>
      <th>H√§ufigkeit</th>
      <th>Jahrzehnt</th>
      <th>L√§nge</th>
      <th>Jahrhundert</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>ellenbogen</td>
      <td>1969</td>
      <td>1</td>
      <td>1960</td>
      <td>10</td>
      <td>20. Jhd.</td>
    </tr>
    <tr>
      <th>1</th>
      <td>atmen</td>
      <td>1969</td>
      <td>1</td>
      <td>1960</td>
      <td>5</td>
      <td>20. Jhd.</td>
    </tr>
    <tr>
      <th>2</th>
      <td>seines</td>
      <td>1969</td>
      <td>1</td>
      <td>1960</td>
      <td>6</td>
      <td>20. Jhd.</td>
    </tr>
    <tr>
      <th>3</th>
      <td>seinerseits</td>
      <td>1969</td>
      <td>1</td>
      <td>1960</td>
      <td>11</td>
      <td>20. Jhd.</td>
    </tr>
    <tr>
      <th>4</th>
      <td>jetzt</td>
      <td>1969</td>
      <td>4</td>
      <td>1960</td>
      <td>5</td>
      <td>20. Jhd.</td>
    </tr>
    <tr>
      <th>...</th>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
    </tr>
    <tr>
      <th>386505</th>
      <td>uhh</td>
      <td>2022</td>
      <td>2</td>
      <td>2020</td>
      <td>3</td>
      <td>21. Jhd.</td>
    </tr>
    <tr>
      <th>386506</th>
      <td>amate</td>
      <td>2022</td>
      <td>1</td>
      <td>2020</td>
      <td>5</td>
      <td>21. Jhd.</td>
    </tr>
    <tr>
      <th>386507</th>
      <td>schlief</td>
      <td>2022</td>
      <td>6</td>
      <td>2020</td>
      <td>7</td>
      <td>21. Jhd.</td>
    </tr>
    <tr>
      <th>386508</th>
      <td>uhren</td>
      <td>2022</td>
      <td>2</td>
      <td>2020</td>
      <td>5</td>
      <td>21. Jhd.</td>
    </tr>
    <tr>
      <th>386509</th>
      <td>bladis</td>
      <td>2022</td>
      <td>3</td>
      <td>2020</td>
      <td>6</td>
      <td>21. Jhd.</td>
    </tr>
  </tbody>
</table>
<p>386510 rows √ó 6 columns</p>
</div></div></div>
</div>
<p>Sehr gut! Bedenke, dass die Begriffe <code class="docutils literal notranslate"><span class="pre">if</span></code> und <code class="docutils literal notranslate"><span class="pre">else</span></code>, die wir bei bedingten Anweisungen in normalem Python verwenden, nicht ben√∂tigt werden. Die Logik ergibt sich einzig √ºber die Reihenfolge der Argumente in <code class="docutils literal notranslate"><span class="pre">where</span></code>.</p>
<p>In diesem Fall haben wir als ‚Äûthen‚Äú bzw. ‚Äûelse‚Äú ganz einfach strings √ºbergeben, die je nach dem in der neuen Spalte ‚ÄûJahrhundert‚Äú eingetragen wurden. In der folgenden √úbung wollen wir bei ‚Äûthen‚Äú und ‚Äûelse‚Äú bestimmte Werte in der jeweilige Zeile bearbeiten.</p>
<hr class="docutils" />
<p>‚úèÔ∏è <strong>√úbung 12:</strong> Bearbeite die Werte in der Spalte ‚ÄûToken‚Äú so, dass jedes Wort, das aus genau f√ºnf Buchstaben besteht, gro√ügeschrieben wird. Einfach weil wir‚Äôs k√∂nnen! üòâ</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1">#In diese Zelle kannst Du den Code zur √úbung schreiben</span>
</pre></div>
</div>
</div>
</div>
<hr class="docutils" />
<p>Super!</p>
<p>F√ºr den Fall, dass Du mehrere bedingte Anweisungen aneinanderh√§ngen willst (<code class="docutils literal notranslate"><span class="pre">if</span></code>-<code class="docutils literal notranslate"><span class="pre">elif</span></code>-‚Ä¶-<code class="docutils literal notranslate"><span class="pre">else</span></code>) kannst Du statt <code class="docutils literal notranslate"><span class="pre">where</span></code> die Numpy-Funktion <code class="docutils literal notranslate"><span class="pre">select</span></code> benutzen. Wir setzen sie weiter unten noch ein.</p>
</section>
<section id="apply-und-applymap">
<h3><code class="docutils literal notranslate"><span class="pre">apply</span></code> und <code class="docutils literal notranslate"><span class="pre">applymap</span></code><a class="headerlink" href="#apply-und-applymap" title="Permalink to this heading">#</a></h3>
<p>Wie erw√§hnt ist die vektorisierte Art der Datenbearbeitung in pandas meistens √§u√üerst effizient. Es gibt aber F√§lle, in denen wir dennoch eine Funktion mit nativem Python-Code anwenden wollen. Entweder, weil pandas die ben√∂tigen Operationen nicht implementiert, oder weil es mit nativem Python-Code trotz allem effizienter ist (dazu gleich mehr).</p>
<p>In jedem Fall bieten die Methoden <code class="docutils literal notranslate"><span class="pre">apply</span></code> und <code class="docutils literal notranslate"><span class="pre">applymap</span></code> die M√∂glichkeit, jede beliebige Funktion (und in der Verl√§ngerung auch jede beliebige Methode) auf eine Series oder gleich ein ganzes DataFrame anzuwenden. <code class="docutils literal notranslate"><span class="pre">apply</span></code> verwenden wir bei einer Series, <code class="docutils literal notranslate"><span class="pre">applymap</span></code> bei einem ganzen DataFrame. Angeh√§ngt an die Series bzw. das DataFrame √ºbergeben wir ihnen schlicht den Namen der gew√ºnschten Funktion. Es spielt keine Rolle, ob die Funktion aus der Grundausstattung von Python stammt, importiert wurde oder von Dir selbst geschrieben ist.</p>
<p>Machen wir es konkret, und zwar in zwei kleinen Experimenten. Wir wollen die gleiche Art der Datenbearbeitung je einmal vektorisiert implementieren, und einmal √ºber eine eigene Funktion, die wir mithilfe von <code class="docutils literal notranslate"><span class="pre">apply</span></code> auf die Daten <em>appli</em>zieren. Zum Verst√§ndnis: Rufen wir eine Funktion √ºber <code class="docutils literal notranslate"><span class="pre">apply</span></code> (oder <code class="docutils literal notranslate"><span class="pre">applymap</span></code>) auf, wird dieser wie bei einem <code class="docutils literal notranslate"><span class="pre">for</span></code>-Loop <em>Wert f√ºr Wert</em> √ºbergeben. Will hei√üen: Bei <code class="docutils literal notranslate"><span class="pre">apply</span></code> k√∂nnen wir nicht von der Verarbeitung mehrerer Daten auf einmal profitieren.</p>
<p>F√ºr das erste Experiment rufen wir ein DataFrame ins Leben, das aus einer Million Zeilen und zwei Spalten, ‚ÄûA‚Äú und ‚ÄûB‚Äú, besteht. Das DataFrame bef√ºllen wir mit zuf√§lligen Zahlen zwischen 0 und 100 (unter Verwendung der numpy-Funktion <code class="docutils literal notranslate"><span class="pre">random.randint</span></code>). Insgesamt also ein ziemlich gro√ües DataFrame:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">exp1</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">100</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="mi">1000000</span><span class="p">,</span><span class="mi">2</span><span class="p">)),</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;A&quot;</span><span class="p">,</span> <span class="s2">&quot;B&quot;</span><span class="p">])</span>
<span class="n">exp1</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html"><div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>A</th>
      <th>B</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>31</td>
      <td>20</td>
    </tr>
    <tr>
      <th>1</th>
      <td>24</td>
      <td>27</td>
    </tr>
    <tr>
      <th>2</th>
      <td>30</td>
      <td>44</td>
    </tr>
    <tr>
      <th>3</th>
      <td>92</td>
      <td>13</td>
    </tr>
    <tr>
      <th>4</th>
      <td>49</td>
      <td>31</td>
    </tr>
  </tbody>
</table>
</div></div></div>
</div>
<p>Nun wollen wir eine dritte Spalte ‚ÄûC‚Äú schaffen, die ganz einfach das jeweilige Produkt der Werte in den Spalten ‚ÄûA‚Äú und ‚ÄûB‚Äú enth√§lt. In der ersten Zelle unten tun wir dies auf vektorisierte Weise, in der zweiten mithilfe einer eigenen Funktion und <code class="docutils literal notranslate"><span class="pre">apply</span></code>. Um zu messen, wie lange das jeweils dauert, verwenden wir das <code class="docutils literal notranslate"><span class="pre">time</span></code>-Modul aus der Grundausstattung von Python:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1">#Vektorisiert</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="c1">#Zeit zum Startpunkt</span>

<span class="n">exp1</span><span class="p">[</span><span class="s2">&quot;C&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">exp1</span><span class="p">[</span><span class="s2">&quot;A&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="n">exp1</span><span class="p">[</span><span class="s2">&quot;B&quot;</span><span class="p">]</span>
<span class="n">vectorized</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="o">-</span><span class="n">start</span> <span class="c1">#Zeit nach Beendigung der Berechnung minus Startzeit, ergibt Dauer</span>

<span class="n">exp1</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html"><div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>A</th>
      <th>B</th>
      <th>C</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>31</td>
      <td>20</td>
      <td>620</td>
    </tr>
    <tr>
      <th>1</th>
      <td>24</td>
      <td>27</td>
      <td>648</td>
    </tr>
    <tr>
      <th>2</th>
      <td>30</td>
      <td>44</td>
      <td>1320</td>
    </tr>
    <tr>
      <th>3</th>
      <td>92</td>
      <td>13</td>
      <td>1196</td>
    </tr>
    <tr>
      <th>4</th>
      <td>49</td>
      <td>31</td>
      <td>1519</td>
    </tr>
  </tbody>
</table>
</div></div></div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1">#for-Loop</span>
<span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="c1">#Zeit zum Startpunkt</span>

<span class="k">def</span> <span class="nf">multiply</span><span class="p">(</span><span class="n">row</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;A&quot;</span><span class="p">]</span><span class="o">*</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;B&quot;</span><span class="p">]</span>

<span class="c1">#dem Funktionsnamen (hier: multiply) folgen keine Klammern!</span>
<span class="c1">#axis=1 spezifiziert, dass wir die Funktion auf Spalten anwenden (s.o.)</span>
<span class="n">exp1</span><span class="p">[</span><span class="s2">&quot;C&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">exp1</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">multiply</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> 

<span class="n">for_loop</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="o">-</span><span class="n">start</span> <span class="c1">#Zeit nach Beendigung der Berechnung minus Startzeit, ergibt Dauer</span>
<span class="n">exp1</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html"><div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>A</th>
      <th>B</th>
      <th>C</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>31</td>
      <td>20</td>
      <td>620</td>
    </tr>
    <tr>
      <th>1</th>
      <td>24</td>
      <td>27</td>
      <td>648</td>
    </tr>
    <tr>
      <th>2</th>
      <td>30</td>
      <td>44</td>
      <td>1320</td>
    </tr>
    <tr>
      <th>3</th>
      <td>92</td>
      <td>13</td>
      <td>1196</td>
    </tr>
    <tr>
      <th>4</th>
      <td>49</td>
      <td>31</td>
      <td>1519</td>
    </tr>
  </tbody>
</table>
</div></div></div>
</div>
<p>Die effektive Berechnungsdauer h√§ngt von verschiedenen Faktoren ab und variiert auch zwischen mehreren Durchg√§ngen. In jedem Fall aber sollte sich ein gro√üer Unterschied zeigen. Typischerweise ist die vektorisierte Berechnung mehrere Hundert Male schneller als die Verwendung einer eigenen Python-Funktion:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Vektorisiert:&quot;</span><span class="p">,</span> <span class="n">vectorized</span><span class="p">,</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">for-Loop&quot;</span><span class="p">,</span> <span class="n">for_loop</span><span class="p">,</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Faktor:&quot;</span><span class="p">,</span> <span class="n">for_loop</span><span class="o">/</span><span class="n">vectorized</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Vektorisiert: 0.010671377182006836 
for-Loop 16.159979343414307 
Faktor: 1514.3293192430572
</pre></div>
</div>
</div>
</div>
<p>Sehr eindrucksvoll!</p>
<p>Gehen wir zum zweiten Experiment √ºber, indem wir wieder ein DataFrame mit einer Million Zeilen, aber nur einer Spalte, ‚ÄûSatz‚Äú, schaffen. Diesmal bef√ºllen wir das DataFrame mit dem immergleichen string (unter Verwendung der numpy-Funktion <code class="docutils literal notranslate"><span class="pre">repeat</span></code>):</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">exp2</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="s2">&quot;Dies ist ein nicht besonders langer Satz.&quot;</span><span class="p">,</span> <span class="mi">1000000</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;Satz&quot;</span><span class="p">])</span>
<span class="n">exp2</span><span class="o">.</span><span class="n">tail</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html"><div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Satz</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>999995</th>
      <td>Dies ist ein nicht besonders langer Satz.</td>
    </tr>
    <tr>
      <th>999996</th>
      <td>Dies ist ein nicht besonders langer Satz.</td>
    </tr>
    <tr>
      <th>999997</th>
      <td>Dies ist ein nicht besonders langer Satz.</td>
    </tr>
    <tr>
      <th>999998</th>
      <td>Dies ist ein nicht besonders langer Satz.</td>
    </tr>
    <tr>
      <th>999999</th>
      <td>Dies ist ein nicht besonders langer Satz.</td>
    </tr>
  </tbody>
</table>
</div></div></div>
</div>
<p>Hier wollen wir ebenfalls eine weitere Spalte schaffen. Sie soll ganz unspektakul√§r die Anzahl an W√∂rtern des jeweiligen strings in der Spalte ‚ÄûSatz‚Äú enthalten. In diesem konstruierten Beispiel ergibt dies selbstverst√§ndlich immer sieben. Die erste Zelle enth√§lt wieder die vektorisierte pandas-Variante, w√§hrend die zweite √ºber <code class="docutils literal notranslate"><span class="pre">apply</span></code> eine selbst geschriebene Funktion mit Python-Code aufruft.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1">#Vektorisiert</span>
<span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

<span class="n">exp2</span><span class="p">[</span><span class="s2">&quot;L√§nge&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">exp2</span><span class="p">[</span><span class="s2">&quot;Satz&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">split</span><span class="p">()</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">len</span><span class="p">()</span>

<span class="n">vectorized</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="o">-</span><span class="n">start</span>

<span class="n">exp2</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html"><div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Satz</th>
      <th>L√§nge</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>Dies ist ein nicht besonders langer Satz.</td>
      <td>7</td>
    </tr>
    <tr>
      <th>1</th>
      <td>Dies ist ein nicht besonders langer Satz.</td>
      <td>7</td>
    </tr>
    <tr>
      <th>2</th>
      <td>Dies ist ein nicht besonders langer Satz.</td>
      <td>7</td>
    </tr>
    <tr>
      <th>3</th>
      <td>Dies ist ein nicht besonders langer Satz.</td>
      <td>7</td>
    </tr>
    <tr>
      <th>4</th>
      <td>Dies ist ein nicht besonders langer Satz.</td>
      <td>7</td>
    </tr>
  </tbody>
</table>
</div></div></div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1">#for-Loop</span>
<span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">split</span><span class="p">(</span><span class="n">sentence</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">sentence</span><span class="o">.</span><span class="n">split</span><span class="p">())</span>

<span class="c1">#dem Funktionsnamen (hier: split) folgen keine Klammern!</span>
<span class="n">exp2</span><span class="p">[</span><span class="s2">&quot;L√§nge&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">exp2</span><span class="p">[</span><span class="s2">&quot;Satz&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">split</span><span class="p">)</span>
<span class="n">for_loop</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="o">-</span><span class="n">start</span>

<span class="n">exp2</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html"><div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Satz</th>
      <th>L√§nge</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>Dies ist ein nicht besonders langer Satz.</td>
      <td>7</td>
    </tr>
    <tr>
      <th>1</th>
      <td>Dies ist ein nicht besonders langer Satz.</td>
      <td>7</td>
    </tr>
    <tr>
      <th>2</th>
      <td>Dies ist ein nicht besonders langer Satz.</td>
      <td>7</td>
    </tr>
    <tr>
      <th>3</th>
      <td>Dies ist ein nicht besonders langer Satz.</td>
      <td>7</td>
    </tr>
    <tr>
      <th>4</th>
      <td>Dies ist ein nicht besonders langer Satz.</td>
      <td>7</td>
    </tr>
  </tbody>
</table>
</div></div></div>
</div>
<p>Auch hier variieren die effektiven Berechnungszeiten mitunter stark, dennoch sollte sich zeigen, dass in diesem Fall die zweite Variante mit nativem Python-Code und <code class="docutils literal notranslate"><span class="pre">apply</span></code> um einiges schneller berechnet wird, selbst wenn der Faktor nicht gleich eindrucksvoll wie oben ist:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Vektorisiert:&quot;</span><span class="p">,</span> <span class="n">vectorized</span><span class="p">,</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">for-Loop&quot;</span><span class="p">,</span> <span class="n">for_loop</span><span class="p">,</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Faktor:&quot;</span><span class="p">,</span> <span class="n">vectorized</span><span class="o">/</span><span class="n">for_loop</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Vektorisiert: 2.6519641876220703 
for-Loop 0.8637270927429199 
Faktor: 3.070372817877327
</pre></div>
</div>
</div>
</div>
<p>Wir k√∂nnen festhalten, dass Vektorisierung bei Zahlen unglaublich effizient ist. Bei der Bearbeitung von strings hinken pandas-Operationen, jedenfalls bei gro√üen Datenmengen, nativem Python-Code hinterher. Es sei denn Du hast riesige Mengen an strings zu bearbeiten, empfiehlt sich der Einsatz von pandas-Operationen der Einheitlichkeit halber i.d.R. dennoch.</p>
<hr class="docutils" />
<p>‚úèÔ∏è <strong>√úbung 13:</strong> Caste s√§mtliche Werte in <code class="docutils literal notranslate"><span class="pre">songkorpus</span></code> in strings.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1">#In diese Zelle kannst Du den Code zur √úbung schreiben</span>
</pre></div>
</div>
</div>
</div>
</section>
</section>
<hr class="docutils" />
<section id="id1">
<h2>üîß Anwendungsfall: Wortverlaufskurven visualisieren üìà<a class="headerlink" href="#id1" title="Permalink to this heading">#</a></h2>
<p>Im Anwendungsfall f√ºr dieses Notebook wollen wir wie gesagt Wortverlaufskurven visualisieren. Das hei√üt, wir wollen die H√§ufigkeit, mit der ein beliebiges Wort auftritt, √ºber die Zeit hinweg darstellen. F√ºr die vier Personalpronomen ‚Äûich‚Äú, ‚Äûdu‚Äú, ‚Äûer‚Äú und ‚Äûsie‚Äú s√§he das z.B. wie in der kombinierten Grafik unten aus. Die linke Darstellung visualisiert die Daten nach einzelnen Jahren (wie der originale Datensatz), in der mittleren und rechten Darstellung werden die Daten aggregiert nach F√ºnfjahresabschnitten bzw. Zehnjahresabschnitten visualisiert. Einzelne Aussschl√§ge nach oben und unten werden so ausgeb√ºgelt und Trends sind leichter zu erkennen:</p>
<img src="../3_Dateien/Grafiken_und_Videos/Wortverlaufskurve_kombiniert.png"><p>Deine Aufgabe ist es erst einmal, Code zu schreiben, der die linke Grafik f√ºr beliebige W√∂rter produziert. Die erforderliche Aggregation f√ºr die mittlere und rechte Darstellung schauen wir uns im Anschluss an den Anwendungsfall gemeinsam an.</p>
<p>Wie im vierten und f√ºnften Notebook hast Du wieder die Wahl, den Anwendungsfall ohne weitere Anleitung in Angriff zu nehmen oder einer Schritt-f√ºr-Schritt-Anleitung zu folgen. In letzterem Fall kannst Du jetzt ans Ende der n√§chsten Code-Zelle springen. Wenn Du es alleine probieren m√∂chstest, dann analysiere das gew√ºnschte Resultat oben links und frage Dich, welche Daten wie und wo visualisiert werden.</p>
<p>üí° Tipp 1: Die relativen H√§ufigkeiten pro Wort und Jahr liegen noch nicht in unserem DataFrame vor. Du musst sie also erst ausrechnen. √úberleg Dir genau, wie Du von den existierenden, absoluten H√§ufigkeiten zu den relativen H√§ufigkeiten pro Jahr kommst. Dazu seien zwei n√ºtzliche Methoden erw√§hnt (klicke auf ihren Namen, um zur offiziellen Dokumentation zu gelangen):</p>
<ul class="simple">
<li><p><a class="reference external" href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.groupby.html"><code class="docutils literal notranslate"><span class="pre">groupby</span></code></a>: Nach dem Motto ‚Äûsplit-apply-combine‚Äú erlaubt Dir diese Methode, das DataFrame nach den Werten der Spalte ‚ÄûJahr‚Äú zu gruppieren (aufzu<em>split</em>ten). Indem Du im gleichen Statement die <code class="docutils literal notranslate"><span class="pre">sum</span></code>-Methode auf die Spalte ‚ÄûH√§ufigkeit‚Äú jedes durch <code class="docutils literal notranslate"><span class="pre">groupby</span></code> entstehenden Sub-DataFrame anwendest (<em>apply</em>), erh√§ltst Du eine zusammengef√ºhrte Series (<em>combine</em>), die f√ºr jedes Jahr die Summe aller H√§ufigkeiten aller Tokens enth√§lt. Schau Dir diese Series genau an.</p></li>
<li><p><a class="reference external" href="https://pandas.pydata.org/docs/reference/api/pandas.Series.replace.html"><code class="docutils literal notranslate"><span class="pre">replace</span></code></a>: Diese Methode l√§sst sich auf eine Series (etwa eine Spalte in unserem DataFrame) anwenden und nimmt u.a. eine zweite Series als Argument (etwa eine durch <code class="docutils literal notranslate"><span class="pre">groupby([...])[...].sum()</span></code> entstandene). <code class="docutils literal notranslate"><span class="pre">replace</span></code> schaut dann, ob sich Indizes der zweiten Series als Werte in der ersten Series befinden und wenn ja, ersetzt sie diese durch die dazugeh√∂rigen Werte aus der zweiten Series. Die dictionary-Analogie von oben macht den Prozess greifbarer: <code class="docutils literal notranslate"><span class="pre">replace</span></code> ersetzt in der Series, auf die sie angewandt wird, Schl√ºssel durch ihre jeweiligen Werte aus der als Argument √ºbergebenen Series.</p></li>
</ul>
<p>üí° Tipp 2: Mach Dich in der <a class="reference external" href="https://matplotlib.org/stable/users/index.html">Dokumentation</a> von matplotlib, der Bibliothek zum Visualisieren von Daten, schlau, wie Du die errechneten Werte visualisieren kannst.</p>
<p>Beginne in jedem Fall damit, die Datei ‚Äûsongkorpus.tsv‚Äú neu einzulesen und die Spalten wie am Anfang des Notebooks umzubenennen. Dadurch stellst Du sicher, dass Du auch wirklich mit den urspr√ºnglichen Daten arbeitest.</p>
<p>Viel Erfolg! üôå</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1">#In diese Zelle kannst Du den Code zur √úbung schreiben.</span>
</pre></div>
</div>
</div>
</div>
<hr class="docutils" />
<p><strong>Schritt-f√ºr-Schritt-Anleitung</strong></p>
<ol class="arabic simple">
<li><p>Um sicherzugehen, dass wir wirklich mit den originalen Daten arbeiten, lies die Datei ‚Äûsongkorpus_token.tsv‚Äú abermals ein.</p></li>
</ol>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1">#In diese Zelle kannst Du den Code zur Aufgabe schreiben.</span>
</pre></div>
</div>
</div>
</div>
<ol class="arabic simple" start="2">
<li><p>Benenne die Spalten in ‚ÄûToken‚Äú, ‚ÄûJahr‚Äú und ‚ÄûH√§ufigkeit‚Äú um.</p></li>
</ol>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1">#In diese Zelle kannst Du den Code zur Aufgabe schreiben.</span>
</pre></div>
</div>
</div>
</div>
<ol class="arabic" start="3">
<li><p>Im DataFrame verf√ºgen wir bislang nur √ºber absolute H√§ufigkeiten. Um die Werte zwischen einzelnen Jahren besser vergleichbar zu machen, wollen wir aber relative H√§ufigkeiten f√ºr die Visualisierung verwenden. Schaffe dazu eine Spalte ‚ÄûRelative H√§ufigkeit‚Äú, die f√ºr jedes Token vermerkt, wie h√§ufig es in Relation zur Summe aller H√§ufigkeiten aller Tokens im gegebenen Jahr vorkommt. F√ºr diese Berechnung brauchst Du jeweils zwei Werte: erstens die absolute H√§ufigkeit (bereits in der Spalte ‚ÄûH√§ufigkeit‚Äú) und zweitens die Summe aller H√§ufigkeiten aller Tokens im gegebenen Jahr.</p>
<p>Verwende die Methode <a class="reference external" href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.groupby.html"><code class="docutils literal notranslate"><span class="pre">groupby</span></code></a> zur Berechnung der Summe aller H√§ufigkeiten pro Jahr. Nach dem Motto ‚Äûsplit-apply-combine‚Äú erlaubt Dir diese Methode, das DataFrame nach den Werten der Spalte ‚ÄûJahr‚Äú zu gruppieren (aufzu<em>split</em>ten). Indem Du im gleichen Statement die <code class="docutils literal notranslate"><span class="pre">sum</span></code>-Methode auf die Spalte ‚ÄûH√§ufigkeit‚Äú jedes durch <code class="docutils literal notranslate"><span class="pre">groupby</span></code> entstehenden Sub-DataFrame anwendest (<em>apply</em>), erh√§ltst Du eine zusammengef√ºhrte Series (<em>combine</em>), die f√ºr jedes Jahr die Summe aller H√§ufigkeiten aller Tokens enth√§lt. Weise die Series der Variablen <code class="docutils literal notranslate"><span class="pre">total_freq_per_year</span></code> zu und inspiziere sie.</p>
<p>Um nun zur relativen H√§ufigkeit zu gelangen, musst Du f√ºr jedes Token in <code class="docutils literal notranslate"><span class="pre">songkorpus</span></code> den Wert in der Spalte ‚ÄûH√§ufigkeit‚Äú durch die jeweilige Summe an H√§ufigkeiten im gegebenen Jahr teilen. Da wir letzteren Wert in einer anderen Series (n√§mlich in <code class="docutils literal notranslate"><span class="pre">total_freq_per_year</span></code>) vorliegen haben, m√ºssen wir zu einem Trick greifen: Wende die <code class="docutils literal notranslate"><span class="pre">replace</span></code>-Methode auf die Spalte ‚ÄûJahr‚Äú an und √ºbergib ihr <code class="docutils literal notranslate"><span class="pre">total_freq_per_year</span></code>. Wir machen uns hier den Umstand zunutze, dass eine Series wie ein dictionary funktioniert. Will hei√üen: <code class="docutils literal notranslate"><span class="pre">replace</span></code> ersetzt kurzerhand jedes Jahr (Schl√ºssel) durch die jeweilige Summe der H√§ufigkeiten pro Jahr (Wert).</p>
</li>
</ol>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1">#In diese Zelle kannst Du den Code zur Aufgabe schreiben.</span>
</pre></div>
</div>
</div>
</div>
<ol class="arabic simple" start="4">
<li><p>Installiere ggf. <code class="docutils literal notranslate"><span class="pre">matplotlib</span></code> √ºber das Terminal oder die Eingabeaufforderung und importiere anschlie√üend <code class="docutils literal notranslate"><span class="pre">matplotlib.pyplot</span> <span class="pre">as</span> <span class="pre">plt</span></code> (wieder so eine g√§ngige Abk√ºrzung). matplotlib ist die Bibliothek, die wir zum Visualisieren unserer Daten verwenden. Mithilfe der Funktion <code class="docutils literal notranslate"><span class="pre">plot(x,</span> <span class="pre">y)</span></code> (denk an den Modulnamen davor) k√∂nnen wir einfach Grafiken produzieren. <code class="docutils literal notranslate"><span class="pre">x</span></code> ist dabei eine Liste oder Series an Werten, die auf der x-Achse abgebildet werden sollen und <code class="docutils literal notranslate"><span class="pre">y</span></code> eine Liste oder Series derjenigen Werte, die auf der y-Achse dargestellt werden sollen. <code class="docutils literal notranslate"><span class="pre">x</span></code> und <code class="docutils literal notranslate"><span class="pre">y</span></code> m√ºssen gleich lange sein. Konkret wird der erste Punkt in der Grafik bei den Koordinaten <code class="docutils literal notranslate"><span class="pre">x[0]</span></code> und <code class="docutils literal notranslate"><span class="pre">y[0]</span></code> eingezeichnet, der zweite bei <code class="docutils literal notranslate"><span class="pre">x[1]</span></code> und <code class="docutils literal notranslate"><span class="pre">y[1]</span></code>, etc. Standardm√§√üig werden die einzelnen Punkte wie oben zu einem Graphen verbunden. Schau in den Beispieldarstellungen oben, welche Werte wir entlang der x-Achse bzw. entlang der y-Achsen plotten wollen.</p></li>
</ol>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1">#In diese Zelle kannst Du den Code zur Aufgabe schreiben.</span>
</pre></div>
</div>
</div>
</div>
<ol class="arabic simple" start="5">
<li><p>Definiere eine Liste an W√∂rtern, die Du visualisieren m√∂chtest. Diesen Schritt kannst Du auch interaktiv umsetzen, sodass Du bei jeder Ausf√ºhrung aufgefordert wirst, W√∂rter zur Visualisierung anzugeben.</p></li>
</ol>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1">#In diese Zelle kannst Du den Code zur Aufgabe schreiben.</span>
</pre></div>
</div>
</div>
</div>
<ol class="arabic simple" start="6">
<li><p>Plotte nun nacheinander eine Verlaufskurve f√ºr jedes Wort auf der Liste. Gehe dazu f√ºr jedes Wort wie folgt vor:</p>
<ul class="simple">
<li><p>Schaffe ein Sub-DataFrame, in dem in der Spalte ‚ÄûToken‚Äú nur das gegebene Wort steht.</p></li>
<li><p>Sortiere das Sub-DataFrame aufsteigend nach der Spalte ‚ÄûJahr‚Äú und setze den Index anschlie√üend zur√ºck.</p></li>
<li><p>√úbergib der <code class="docutils literal notranslate"><span class="pre">plot</span></code>-Funktion die relevanten Spalten des Sub-DataFrames an Stelle von <code class="docutils literal notranslate"><span class="pre">x</span></code> und <code class="docutils literal notranslate"><span class="pre">y</span></code>. √úbergib als drittes Argument den string ‚Äûo-‚Äú, der den Stil des Graphen (Linie mit Punkten) definiert.</p></li>
</ul>
</li>
</ol>
<ol class="arabic simple" start="7">
<li><p>Nachdem Du alle W√∂rter der Liste entsprechend geplotted hast, kannst Du <strong>in derselben Zelle</strong> folgende Funktionen verwenden, um den Plot zu verfeinern:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">title</span></code>, um einen Titel zu setzen.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">xlabel</span></code> und  <code class="docutils literal notranslate"><span class="pre">ylabel</span></code>, um die Achsen zu beschriften.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">xlim</span></code>, um der x-Achse Grenzen zu setzen, z.B. von 1969 bis 2022 (dies vereinheitlicht die Plots, da diese sonst automatisch an den Wertebereich der zu plottenden W√∂rter angepasst wird und der Plot dadurch mitunter anders beschnitten sein kann).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">legend</span></code>, um eine Legende einzuf√ºgen, indem Du der Funktion die Liste mit W√∂rtern √ºbergibst</p></li>
</ul>
</li>
</ol>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1">#In diese Zelle kannst Du den Code zur Aufgabe schreiben.</span>
</pre></div>
</div>
</div>
</div>
<hr class="docutils" />
<p>Super! ü§©</p>
<p>Bevor wir uns zum Abschluss noch den Output von DataFrames anschauen, wollen wir die Daten wie gesagt zu gr√∂√üeren Zeiteinheiten aggregieren, und zwar zu Zehn- und F√ºnfjahresabschnitten.</p>
<p>Auch hier laden wir zur Sicherheit nochmal die originale Datei, benennen die Spalten um und schaffen zus√§tzlich die Spalten ‚ÄûJahrzehnt‚Äú und ‚ÄûRelative H√§ufigkeit‚Äú. Letztere wird nach wie vor relativ zur H√§ufigkeit aller Tokens in <em>einem</em> Jahr berechnet.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">songkorpus</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s2">&quot;../3_Dateien/Songkorpus/songkorpus_token.tsv&quot;</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span><span class="p">)</span> 

<span class="n">songkorpus</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;Token&quot;</span><span class="p">,</span> <span class="s2">&quot;Jahr&quot;</span><span class="p">,</span> <span class="s2">&quot;H√§ufigkeit&quot;</span><span class="p">]</span>

<span class="c1">#hier verwenden wir im Gegensatz zu oben die pandas-eigene Syntax</span>
<span class="n">songkorpus</span><span class="p">[</span><span class="s2">&quot;Jahrzehnt&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">songkorpus</span><span class="p">[</span><span class="s2">&quot;Jahr&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;0&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span> 

<span class="n">total_freq_per_year</span> <span class="o">=</span> <span class="n">songkorpus</span><span class="o">.</span><span class="n">groupby</span><span class="p">([</span><span class="s2">&quot;Jahr&quot;</span><span class="p">])[</span><span class="s2">&quot;H√§ufigkeit&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
<span class="n">songkorpus</span><span class="p">[</span><span class="s2">&quot;Relative H√§ufigkeit&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">songkorpus</span><span class="p">[</span><span class="s2">&quot;H√§ufigkeit&quot;</span><span class="p">]</span> <span class="o">/</span> <span class="n">songkorpus</span><span class="p">[</span><span class="s2">&quot;Jahr&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">total_freq_per_year</span><span class="p">)</span> 

<span class="n">songkorpus</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html"><div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Token</th>
      <th>Jahr</th>
      <th>H√§ufigkeit</th>
      <th>Jahrzehnt</th>
      <th>Relative H√§ufigkeit</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>Klaround</td>
      <td>2007</td>
      <td>1</td>
      <td>2000</td>
      <td>0.000015</td>
    </tr>
    <tr>
      <th>1</th>
      <td>#3</td>
      <td>2009</td>
      <td>1</td>
      <td>2000</td>
      <td>0.000022</td>
    </tr>
    <tr>
      <th>2</th>
      <td>#Babo</td>
      <td>2015</td>
      <td>1</td>
      <td>2010</td>
      <td>0.000015</td>
    </tr>
    <tr>
      <th>3</th>
      <td>#JeSuisPass√©ChezSo</td>
      <td>2018</td>
      <td>1</td>
      <td>2010</td>
      <td>0.000012</td>
    </tr>
    <tr>
      <th>4</th>
      <td>#Nachbar</td>
      <td>2016</td>
      <td>1</td>
      <td>2010</td>
      <td>0.000014</td>
    </tr>
  </tbody>
</table>
</div></div></div>
</div>
<p>Eine Spalte mit sog. <em>Jahrf√ºnften</em> k√∂nnen wir nun unter Verwendung von numpys <code class="docutils literal notranslate"><span class="pre">select</span></code> erstellen. Dazu definieren wir zwei Listen, eine mit ‚Äûif‚Äú-Bedingungen (etwa ‚ÄûWert in Spalte ‚ÄöJahr‚Äò kleiner als 1970‚Ä¶‚Äú) und eine mit ‚Äûthen‚Äú-Statements (‚Äú‚Ä¶dann setze den Wert 1965 ein‚Äú). Diese Listen √ºbergeben wir der Funktion zusammen mit dem dritten Argument, das ganz einfach im ‚Äûelse‚Äú-Fall greift. Bedenke, dass die Reihenfolge der Elemente auf den beiden Listen ebenso wie die Reihenfolge von <code class="docutils literal notranslate"><span class="pre">if</span></code>-<code class="docutils literal notranslate"><span class="pre">elif</span></code>-‚Ä¶-Statements in normalem Python-Code entscheidend ist.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="n">songkorpus</span><span class="p">[</span><span class="s2">&quot;Jahr&quot;</span><span class="p">]</span>
<span class="n">if_list</span>   <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">&lt;</span><span class="mi">1970</span><span class="p">,</span> <span class="n">x</span><span class="o">&lt;</span><span class="mi">1975</span><span class="p">,</span> <span class="n">x</span><span class="o">&lt;</span><span class="mi">1980</span><span class="p">,</span> <span class="n">x</span><span class="o">&lt;</span><span class="mi">1985</span><span class="p">,</span> <span class="n">x</span><span class="o">&lt;</span><span class="mi">1990</span><span class="p">,</span> <span class="n">x</span><span class="o">&lt;</span><span class="mi">1995</span><span class="p">,</span> <span class="n">x</span><span class="o">&lt;</span><span class="mi">2000</span><span class="p">,</span> <span class="n">x</span><span class="o">&lt;</span><span class="mi">2005</span><span class="p">,</span> <span class="n">x</span><span class="o">&lt;</span><span class="mi">2010</span><span class="p">,</span> <span class="n">x</span><span class="o">&lt;</span><span class="mi">2015</span><span class="p">,</span> <span class="n">x</span><span class="o">&lt;</span><span class="mi">2020</span><span class="p">]</span> <span class="c1">#hier zeigt sich auch, warum wir die Spalte &quot;Jahr&quot; oben in Ganzzahlen gecasted haben</span>
<span class="n">then_list</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1965</span><span class="p">,</span> <span class="mi">1970</span><span class="p">,</span> <span class="mi">1975</span><span class="p">,</span> <span class="mi">1980</span><span class="p">,</span> <span class="mi">1985</span><span class="p">,</span> <span class="mi">1990</span><span class="p">,</span> <span class="mi">1995</span><span class="p">,</span> <span class="mi">2000</span><span class="p">,</span> <span class="mi">2005</span><span class="p">,</span> <span class="mi">2010</span><span class="p">,</span> <span class="mi">2015</span><span class="p">]</span>
<span class="n">songkorpus</span><span class="p">[</span><span class="s2">&quot;Jahrf√ºnft&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">if_list</span><span class="p">,</span> <span class="n">then_list</span><span class="p">,</span> <span class="mi">2020</span><span class="p">)</span>
<span class="n">songkorpus</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html"><div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Token</th>
      <th>Jahr</th>
      <th>H√§ufigkeit</th>
      <th>Jahrzehnt</th>
      <th>Relative H√§ufigkeit</th>
      <th>Jahrf√ºnft</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>Klaround</td>
      <td>2007</td>
      <td>1</td>
      <td>2000</td>
      <td>0.000015</td>
      <td>2005</td>
    </tr>
    <tr>
      <th>1</th>
      <td>#3</td>
      <td>2009</td>
      <td>1</td>
      <td>2000</td>
      <td>0.000022</td>
      <td>2005</td>
    </tr>
    <tr>
      <th>2</th>
      <td>#Babo</td>
      <td>2015</td>
      <td>1</td>
      <td>2010</td>
      <td>0.000015</td>
      <td>2015</td>
    </tr>
    <tr>
      <th>3</th>
      <td>#JeSuisPass√©ChezSo</td>
      <td>2018</td>
      <td>1</td>
      <td>2010</td>
      <td>0.000012</td>
      <td>2015</td>
    </tr>
    <tr>
      <th>4</th>
      <td>#Nachbar</td>
      <td>2016</td>
      <td>1</td>
      <td>2010</td>
      <td>0.000014</td>
      <td>2015</td>
    </tr>
  </tbody>
</table>
</div></div></div>
</div>
<p>Nun fehlt nur noch der Aggregationsschritt. Bei den jahresbasierten relativen H√§ufigkeiten konnten wir uns ja darauf verlassen, dass jedes Wort nur ein einziges Mal pro Jahr in unserem DataFrame steht, so sind unsere Daten ganz einfach strukturiert.</p>
<p>Bei den Jahrf√ºnften und Jahrzehnten kann ein einzelnes Wort hingegen bis zu f√ºnf bzw. zehn Mal vorkommen. Da wir aber nur einen Wert pro Zeitabschnitt plotten wollen, m√ºssen wir s√§mtliche relativen H√§ufigkeiten in einem Jahrf√ºnft bzw. Jahrzehnt aufsummieren und anschlie√üend durch 5 resp. 10 teilen. Dadurch erhalten wir die durchschnittliche relative H√§ufigkeit pro Wort und Zeitabschnitt.</p>
<p>Genau dies tun wir im neu eingef√ºgten Aggregationsschritt unten: Wir gruppieren das Sub-DataFrame <code class="docutils literal notranslate"><span class="pre">word_df</span></code> abermals mithilfe von <code class="docutils literal notranslate"><span class="pre">groupby</span></code> nach dem gew√ºnschten Zeitabschnitt (wahlweise Jahrzehnt oder Jahrf√ºnft) und aggregieren die Werte in der Spalte ‚ÄûRelative H√§ufigkeit‚Äú, indem wir sie pro Zeitabschnitt aufsummieren. Anschlie√üend teilen wir die Summe durch die Anzahl an Jahre des Zeitabschnitts (10 oder 5), um den Durchschnitt zu errechnen. Um wirklich nur mit kompletten Jahrf√ºnften bzw. Jahrzehnten zu rechnen, exkludieren wir zu Beginn noch s√§mtliche Tokens in den Jahren 1969, 2020, 2021 und 2022 (die Division durch 5 bzw. 10 w√ºrde ja sonst zu zu kleinen Durchschnitten f√ºhren).</p>
<p>Abgesehen vom Aggregationsschritt und dem Ausschluss inkompletter Jahrf√ºnfte bzw. Jahrzehnte, wurde im Code unten die Variable <code class="docutils literal notranslate"><span class="pre">span</span></code> f√ºr die Zeiteinheit eingesetzt, sodass diese neben zu den zu plottenden W√∂rtern initial definiert werden kann:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">span</span><span class="p">,</span> <span class="n">span_dict</span> <span class="o">=</span> <span class="s2">&quot;Jahrzehnt&quot;</span><span class="p">,</span> <span class="p">{</span><span class="s2">&quot;Jahrzehnt&quot;</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span> <span class="s2">&quot;Jahrf√ºnft&quot;</span><span class="p">:</span> <span class="mi">5</span><span class="p">}</span>
<span class="n">words</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;ich&quot;</span><span class="p">,</span> <span class="s2">&quot;du&quot;</span><span class="p">,</span> <span class="s2">&quot;er&quot;</span><span class="p">,</span> <span class="s2">&quot;sie&quot;</span><span class="p">]</span>

<span class="c1">#Ausschluss inkompletter Jahrf√ºnfte bzw. Jahrzehnte durch Kombination zweier Filter</span>
<span class="n">songkorpus</span> <span class="o">=</span> <span class="n">songkorpus</span><span class="p">[(</span><span class="n">songkorpus</span><span class="p">[</span><span class="s2">&quot;Jahr&quot;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1969</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">songkorpus</span><span class="p">[</span><span class="s2">&quot;Jahr&quot;</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">2020</span><span class="p">)]</span>

<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

<span class="k">for</span> <span class="n">word</span> <span class="ow">in</span> <span class="n">words</span><span class="p">:</span>
    <span class="n">word_df</span> <span class="o">=</span> <span class="n">songkorpus</span><span class="p">[</span><span class="n">songkorpus</span><span class="p">[</span><span class="s2">&quot;Token&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">word</span><span class="p">]</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;NEUER SCHRITT: AGGREGATION&quot;&quot;&quot;</span>
    <span class="n">word_df</span> <span class="o">=</span> <span class="n">word_df</span><span class="o">.</span><span class="n">groupby</span><span class="p">([</span><span class="n">span</span><span class="p">])</span><span class="o">.</span><span class="n">aggregate</span><span class="p">({</span><span class="s2">&quot;Relative H√§ufigkeit&quot;</span><span class="p">:</span> <span class="s2">&quot;sum&quot;</span><span class="p">})</span> <span class="o">/</span> <span class="n">span_dict</span><span class="p">[</span><span class="n">span</span><span class="p">]</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;NEUER SCHRITT: AGGREGATION&quot;&quot;&quot;</span>
    
    
    <span class="n">word_df</span> <span class="o">=</span> <span class="n">word_df</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="n">by</span><span class="o">=</span><span class="n">span</span><span class="p">,</span> <span class="n">ascending</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">word_df</span><span class="p">[</span><span class="n">span</span><span class="p">]</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">word_df</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;Relative H√§ufigkeit&quot;</span><span class="p">]</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="s1">&#39;o-&#39;</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Wortverlaufskurve f√ºr </span><span class="si">{</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">word</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">word</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">words</span><span class="p">])</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="n">span</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Relative H√§ufigkeit (</span><span class="si">{</span><span class="n">span</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlim</span><span class="p">(</span><span class="mi">1969</span><span class="p">,</span> <span class="mi">2011</span><span class="p">)</span> <span class="c1">#Anpassen, je nach Zeitabschnitt</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">words</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="s2">&quot;best&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>&lt;matplotlib.legend.Legend at 0x7f33201adad0&gt;
</pre></div>
</div>
<img alt="../../_images/3a4b20bd1cbaf8f4011759a3b1ab74cad26bbc5c67e8e32d93007b3dc3cbaaa5.png" src="../../_images/3a4b20bd1cbaf8f4011759a3b1ab74cad26bbc5c67e8e32d93007b3dc3cbaaa5.png" />
</div>
</div>
<p>Wunderbar.</p>
<p>Sollte hier neben dem Plot auch eine <code class="docutils literal notranslate"><span class="pre">SettingWithCopyWarning</span></code> zur√ºckgegeben worden sein, kannst du diese ignorieren.</p>
<p>Mit <code class="docutils literal notranslate"><span class="pre">plt.savefig(path)</span></code> kannst Du Grafiken √ºbrigens auch auf Deiner Festplatte speichern.</p>
<p>Damit sind wir fast am Ende des Notebooks angelangt.</p>
</section>
<section id="output">
<h2>Output<a class="headerlink" href="#output" title="Permalink to this heading">#</a></h2>
<p>√úbrig bleibt noch, die Methode <code class="docutils literal notranslate"><span class="pre">to_csv</span></code> vorzustellen, die wir verwenden k√∂nnen, um ein DataFrame als kommaseparierte Datei extern zu speichern:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">songkorpus</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="s2">&quot;../3_Dateien/Output/songkorpus_new.csv&quot;</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s2">&quot;utf-8&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Neben dem Ausgabepfad k√∂nnen wir das gew√ºnschte Trennzeichen und Encoding spezifizieren. Neben <code class="docutils literal notranslate"><span class="pre">to_csv</span></code> gibt es analog zum Input auch spezifische Output-Methoden f√ºr XML (<code class="docutils literal notranslate"><span class="pre">to_xml</span></code>), JSON (<code class="docutils literal notranslate"><span class="pre">to_json</span></code>) und Excel (<code class="docutils literal notranslate"><span class="pre">to_excel</span></code>).</p>
<p>Damit sind wir am Ende des Notebooks angelangt. Gute Arbeit!</p>
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "yannickfrommherz/yfrommherz.ch",
            ref: "main",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            name: "python3",
            path: "./programming/1_Notebooks"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

                </article>
              

              
              
                <footer class="bd-footer-article">
                  
<div class="footer-article-items footer-article__inner">
  
    <div class="footer-article-item"><!-- Previous / next buttons -->
<div class="prev-next-area">
    <a class="left-prev"
       href="6_Regulaere_Ausdruecke.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">zur√ºck</p>
        <p class="prev-next-title">Regul√§re Ausdr√ºcke / RegEx</p>
      </div>
    </a>
    <a class="right-next"
       href="../../solutions.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">weiter</p>
        <p class="prev-next-title">L√∂sungen</p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div></div>
  
</div>

                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">

  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> Inhalt
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#input">Input</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#uberblick-bekommen">√úberblick bekommen</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#anwendungsfall-wortverlaufskurven-visualisieren">üîß Anwendungsfall: Wortverlaufskurven visualisieren üìà</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#auf-spalten-zugreifen">Auf Spalten zugreifen</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#auf-zeilen-zugreifen">Auf Zeilen zugreifen</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#auf-spalten-und-zeilen-zugreifen">Auf Spalten <em>und</em> Zeilen zugreifen</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#spalten-hinzufugen">Spalten hinzuf√ºgen</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#zeilen-hinzufugen">Zeilen hinzuf√ºgen</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#spalten-und-zeilen-entfernen">Spalten und Zeilen entfernen</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#deskriptive-statistiken">Deskriptive Statistiken</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#werte-sortieren">Werte sortieren</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#einzigartige-werte">Einzigartige Werte</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#dataframe-filtern">DataFrame filtern</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#werte-zahlen">Werte z√§hlen</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#werte-bearbeiten">Werte bearbeiten</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#strings">Strings</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#numerische-werte">Numerische Werte</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#datentyp-andern">Datentyp √§ndern</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#bedingte-bearbeitung">Bedingte Bearbeitung</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#apply-und-applymap"><code class="docutils literal notranslate"><span class="pre">apply</span></code> und <code class="docutils literal notranslate"><span class="pre">applymap</span></code></a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id1">üîß Anwendungsfall: Wortverlaufskurven visualisieren üìà</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#output">Output</a></li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
Durch Yannick Frommherz
</p>

  </div>
  
  <div class="footer-item">
    
  <p class="copyright">
    
      ¬© Copyright 2023.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
<div class="extra_footer">
  <div>
<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/"><img class="license" alt="Creative Commons License" src="https://i.creativecommons.org/l/by-nc-sa/4.0/80x15.png" /></a> This page is licensed under a <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">Creative Commons BY-NC-SA 4.0 License</a>.
</div>

</div>
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../../_static/scripts/bootstrap.js?digest=e353d410970836974a52"></script>
<script src="../../_static/scripts/pydata-sphinx-theme.js?digest=e353d410970836974a52"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>